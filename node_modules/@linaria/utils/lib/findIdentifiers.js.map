{"version":3,"file":"findIdentifiers.js","names":["isInVoid","path","parentPath","isUnaryExpression","operator","isBindingIdentifier","isReferencedIdentifier","checkers","binding","ex","both","referenced","nonType","find","p","isTSTypeReference","isTSTypeQuery","isFlowType","isFlowDeclaration","isTSInterfaceDeclaration","findIdentifiers","expressions","type","identifiers","forEach","emit","node","removed","getScope","getBinding","name","isAncestor","push","isIdentifier","isJSXIdentifier","traverse","TSTypeAnnotation","skip","Identifier","JSXIdentifier"],"sources":["../src/findIdentifiers.ts"],"sourcesContent":["import type { NodePath } from '@babel/traverse';\nimport type { Node, Identifier, JSXIdentifier } from '@babel/types';\n\nimport { getScope } from './getScope';\n\ntype FindType = 'binding' | 'both' | 'referenced';\n\nfunction isInVoid(path: NodePath): boolean {\n  return path.parentPath?.isUnaryExpression({ operator: 'void' }) ?? false;\n}\n\nfunction isBindingIdentifier(path: NodePath): path is NodePath<Identifier> {\n  return path.isBindingIdentifier() && !isInVoid(path);\n}\n\nfunction isReferencedIdentifier(\n  path: NodePath\n): path is NodePath<Identifier | JSXIdentifier> {\n  return path.isReferencedIdentifier() || isInVoid(path);\n}\n\n// For some reasons, `isBindingIdentifier` returns true for identifiers inside `void` expressions.\nconst checkers: Record<FindType, (ex: NodePath) => boolean> = {\n  binding: (ex) => isBindingIdentifier(ex),\n  both: (ex) => isBindingIdentifier(ex) || isReferencedIdentifier(ex),\n  referenced: (ex) => isReferencedIdentifier(ex),\n};\n\nexport function nonType(path: NodePath): boolean {\n  return !path.find(\n    (p) =>\n      p.isTSTypeReference() ||\n      p.isTSTypeQuery() ||\n      p.isFlowType() ||\n      p.isFlowDeclaration() ||\n      p.isTSInterfaceDeclaration()\n  );\n}\n\nexport default function findIdentifiers(\n  expressions: NodePath<Node | null | undefined>[],\n  type: FindType = 'referenced'\n): NodePath<Identifier | JSXIdentifier>[] {\n  const identifiers: NodePath<Identifier | JSXIdentifier>[] = [];\n\n  expressions.forEach((ex) => {\n    const emit = (path: NodePath<Identifier | JSXIdentifier>) => {\n      if (!path.node || path.removed || !checkers[type](path)) {\n        return;\n      }\n\n      if (!nonType(path)) {\n        // If skip in TSTypeAnnotation visitor doesn't work\n        return;\n      }\n\n      // TODO: Is there a better way to check that it's a local variable?\n\n      const binding = getScope(path).getBinding(path.node.name);\n      if (!binding) {\n        return;\n      }\n\n      if (type === 'referenced' && ex.isAncestor(binding.path)) {\n        // This identifier is declared inside the expression. We don't need it.\n        return;\n      }\n\n      identifiers.push(path);\n    };\n\n    if (ex.isIdentifier() || ex.isJSXIdentifier()) {\n      emit(ex);\n    } else {\n      ex.traverse({\n        TSTypeAnnotation(path) {\n          // We ignore identifiers in type annotations\n          // It will produce broken TS code, but we don't care\n          path.skip();\n        },\n        Identifier(path: NodePath<Identifier>) {\n          emit(path);\n        },\n        JSXIdentifier(path: NodePath<JSXIdentifier>) {\n          emit(path);\n        },\n      });\n    }\n  });\n\n  return identifiers;\n}\n"],"mappings":";;;;;;;AAGA;AAIA,SAASA,QAAQ,CAACC,IAAc,EAAW;EAAA;EACzC,oDAAOA,IAAI,CAACC,UAAU,qDAAf,iBAAiBC,iBAAiB,CAAC;IAAEC,QAAQ,EAAE;EAAO,CAAC,CAAC,yEAAI,KAAK;AAC1E;AAEA,SAASC,mBAAmB,CAACJ,IAAc,EAAgC;EACzE,OAAOA,IAAI,CAACI,mBAAmB,EAAE,IAAI,CAACL,QAAQ,CAACC,IAAI,CAAC;AACtD;AAEA,SAASK,sBAAsB,CAC7BL,IAAc,EACgC;EAC9C,OAAOA,IAAI,CAACK,sBAAsB,EAAE,IAAIN,QAAQ,CAACC,IAAI,CAAC;AACxD;;AAEA;AACA,MAAMM,QAAqD,GAAG;EAC5DC,OAAO,EAAGC,EAAE,IAAKJ,mBAAmB,CAACI,EAAE,CAAC;EACxCC,IAAI,EAAGD,EAAE,IAAKJ,mBAAmB,CAACI,EAAE,CAAC,IAAIH,sBAAsB,CAACG,EAAE,CAAC;EACnEE,UAAU,EAAGF,EAAE,IAAKH,sBAAsB,CAACG,EAAE;AAC/C,CAAC;AAEM,SAASG,OAAO,CAACX,IAAc,EAAW;EAC/C,OAAO,CAACA,IAAI,CAACY,IAAI,CACdC,CAAC,IACAA,CAAC,CAACC,iBAAiB,EAAE,IACrBD,CAAC,CAACE,aAAa,EAAE,IACjBF,CAAC,CAACG,UAAU,EAAE,IACdH,CAAC,CAACI,iBAAiB,EAAE,IACrBJ,CAAC,CAACK,wBAAwB,EAAE,CAC/B;AACH;AAEe,SAASC,eAAe,CACrCC,WAAgD,EAChDC,IAAc,GAAG,YAAY,EACW;EACxC,MAAMC,WAAmD,GAAG,EAAE;EAE9DF,WAAW,CAACG,OAAO,CAAEf,EAAE,IAAK;IAC1B,MAAMgB,IAAI,GAAIxB,IAA0C,IAAK;MAC3D,IAAI,CAACA,IAAI,CAACyB,IAAI,IAAIzB,IAAI,CAAC0B,OAAO,IAAI,CAACpB,QAAQ,CAACe,IAAI,CAAC,CAACrB,IAAI,CAAC,EAAE;QACvD;MACF;MAEA,IAAI,CAACW,OAAO,CAACX,IAAI,CAAC,EAAE;QAClB;QACA;MACF;;MAEA;;MAEA,MAAMO,OAAO,GAAG,IAAAoB,kBAAQ,EAAC3B,IAAI,CAAC,CAAC4B,UAAU,CAAC5B,IAAI,CAACyB,IAAI,CAACI,IAAI,CAAC;MACzD,IAAI,CAACtB,OAAO,EAAE;QACZ;MACF;MAEA,IAAIc,IAAI,KAAK,YAAY,IAAIb,EAAE,CAACsB,UAAU,CAACvB,OAAO,CAACP,IAAI,CAAC,EAAE;QACxD;QACA;MACF;MAEAsB,WAAW,CAACS,IAAI,CAAC/B,IAAI,CAAC;IACxB,CAAC;IAED,IAAIQ,EAAE,CAACwB,YAAY,EAAE,IAAIxB,EAAE,CAACyB,eAAe,EAAE,EAAE;MAC7CT,IAAI,CAAChB,EAAE,CAAC;IACV,CAAC,MAAM;MACLA,EAAE,CAAC0B,QAAQ,CAAC;QACVC,gBAAgB,CAACnC,IAAI,EAAE;UACrB;UACA;UACAA,IAAI,CAACoC,IAAI,EAAE;QACb,CAAC;QACDC,UAAU,CAACrC,IAA0B,EAAE;UACrCwB,IAAI,CAACxB,IAAI,CAAC;QACZ,CAAC;QACDsC,aAAa,CAACtC,IAA6B,EAAE;UAC3CwB,IAAI,CAACxB,IAAI,CAAC;QACZ;MACF,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;EAEF,OAAOsB,WAAW;AACpB"}