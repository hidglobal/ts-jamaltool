{"version":3,"file":"JSXElementsRemover.js","names":["getFunctionName","path","isClassMethod","t","isIdentifier","node","key","name","JSXElementsRemover","nullLiteral","functionScope","getScope","getFunctionParent","scopePath","isFunction","emptyBody","blockStatement","returnStatement","decl","findParent","p","isClassDeclaration","mutate","replaceWith","functionDeclaration","id","body","get","Array","isArray","Error","params"],"sources":["../../src/visitors/JSXElementsRemover.ts"],"sourcesContent":["import { types as t } from '@babel/core';\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  CallExpression,\n  Function as FunctionNode,\n  JSX,\n} from '@babel/types';\n\nimport { getScope } from '../getScope';\nimport { mutate } from '../scopeHelpers';\n\nfunction getFunctionName(path: NodePath<FunctionNode>): string | null {\n  if (path.isClassMethod() && t.isIdentifier(path.node.key)) {\n    return path.node.key.name;\n  }\n\n  return null;\n}\n\nexport default function JSXElementsRemover(\n  path: NodePath<JSX | CallExpression>\n) {\n  // JSX can be safely replaced with null because it is unnecessary for styles\n  const nullLiteral = t.nullLiteral();\n\n  // We can do even more\n  // If that JSX is a result of a function, we can replace the function body.\n  const functionScope = getScope(path).getFunctionParent();\n  const scopePath = functionScope?.path;\n  if (scopePath?.isFunction()) {\n    const emptyBody = t.blockStatement([t.returnStatement(nullLiteral)]);\n\n    // Is it not just a function, but a method `render`?\n    if (getFunctionName(scopePath) === 'render') {\n      const decl = scopePath.findParent((p) => p.isClassDeclaration());\n\n      // Replace the whole component\n      if (decl?.isClassDeclaration()) {\n        mutate(decl, (p) => {\n          p.replaceWith(t.functionDeclaration(decl.node.id, [], emptyBody));\n        });\n\n        return;\n      }\n    }\n\n    const body = scopePath.get('body');\n    if (Array.isArray(body)) {\n      throw new Error(\n        \"A body of a function is expected to be a single element but an array was returned. It's possible if JS syntax has been changed since that code was written.\"\n      );\n    }\n\n    const node: typeof scopePath.node = {\n      ...scopePath.node,\n      body: emptyBody,\n      params: [],\n    };\n\n    mutate(scopePath, (p) => {\n      p.replaceWith(node);\n    });\n  } else {\n    mutate(path, (p) => {\n      p.replaceWith(nullLiteral);\n    });\n  }\n}\n"],"mappings":";;;;;;AAAA;AAQA;AACA;AAEA,SAASA,eAAe,CAACC,IAA4B,EAAiB;EACpE,IAAIA,IAAI,CAACC,aAAa,EAAE,IAAIC,WAAC,CAACC,YAAY,CAACH,IAAI,CAACI,IAAI,CAACC,GAAG,CAAC,EAAE;IACzD,OAAOL,IAAI,CAACI,IAAI,CAACC,GAAG,CAACC,IAAI;EAC3B;EAEA,OAAO,IAAI;AACb;AAEe,SAASC,kBAAkB,CACxCP,IAAoC,EACpC;EACA;EACA,MAAMQ,WAAW,GAAGN,WAAC,CAACM,WAAW,EAAE;;EAEnC;EACA;EACA,MAAMC,aAAa,GAAG,IAAAC,kBAAQ,EAACV,IAAI,CAAC,CAACW,iBAAiB,EAAE;EACxD,MAAMC,SAAS,GAAGH,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAET,IAAI;EACrC,IAAIY,SAAS,aAATA,SAAS,eAATA,SAAS,CAAEC,UAAU,EAAE,EAAE;IAC3B,MAAMC,SAAS,GAAGZ,WAAC,CAACa,cAAc,CAAC,CAACb,WAAC,CAACc,eAAe,CAACR,WAAW,CAAC,CAAC,CAAC;;IAEpE;IACA,IAAIT,eAAe,CAACa,SAAS,CAAC,KAAK,QAAQ,EAAE;MAC3C,MAAMK,IAAI,GAAGL,SAAS,CAACM,UAAU,CAAEC,CAAC,IAAKA,CAAC,CAACC,kBAAkB,EAAE,CAAC;;MAEhE;MACA,IAAIH,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEG,kBAAkB,EAAE,EAAE;QAC9B,IAAAC,oBAAM,EAACJ,IAAI,EAAGE,CAAC,IAAK;UAClBA,CAAC,CAACG,WAAW,CAACpB,WAAC,CAACqB,mBAAmB,CAACN,IAAI,CAACb,IAAI,CAACoB,EAAE,EAAE,EAAE,EAAEV,SAAS,CAAC,CAAC;QACnE,CAAC,CAAC;QAEF;MACF;IACF;IAEA,MAAMW,IAAI,GAAGb,SAAS,CAACc,GAAG,CAAC,MAAM,CAAC;IAClC,IAAIC,KAAK,CAACC,OAAO,CAACH,IAAI,CAAC,EAAE;MACvB,MAAM,IAAII,KAAK,CACb,6JAA6J,CAC9J;IACH;IAEA,MAAMzB,IAA2B,GAAG;MAClC,GAAGQ,SAAS,CAACR,IAAI;MACjBqB,IAAI,EAAEX,SAAS;MACfgB,MAAM,EAAE;IACV,CAAC;IAED,IAAAT,oBAAM,EAACT,SAAS,EAAGO,CAAC,IAAK;MACvBA,CAAC,CAACG,WAAW,CAAClB,IAAI,CAAC;IACrB,CAAC,CAAC;EACJ,CAAC,MAAM;IACL,IAAAiB,oBAAM,EAACrB,IAAI,EAAGmB,CAAC,IAAK;MAClBA,CAAC,CAACG,WAAW,CAACd,WAAW,CAAC;IAC5B,CAAC,CAAC;EACJ;AACF"}