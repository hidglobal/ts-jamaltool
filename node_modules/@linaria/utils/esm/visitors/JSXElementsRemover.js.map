{"version":3,"file":"JSXElementsRemover.js","names":["types","t","getScope","mutate","getFunctionName","path","isClassMethod","isIdentifier","node","key","name","JSXElementsRemover","nullLiteral","functionScope","getFunctionParent","scopePath","isFunction","emptyBody","blockStatement","returnStatement","decl","findParent","p","isClassDeclaration","replaceWith","functionDeclaration","id","body","get","Array","isArray","Error","params"],"sources":["../../src/visitors/JSXElementsRemover.ts"],"sourcesContent":["import { types as t } from '@babel/core';\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  CallExpression,\n  Function as FunctionNode,\n  JSX,\n} from '@babel/types';\n\nimport { getScope } from '../getScope';\nimport { mutate } from '../scopeHelpers';\n\nfunction getFunctionName(path: NodePath<FunctionNode>): string | null {\n  if (path.isClassMethod() && t.isIdentifier(path.node.key)) {\n    return path.node.key.name;\n  }\n\n  return null;\n}\n\nexport default function JSXElementsRemover(\n  path: NodePath<JSX | CallExpression>\n) {\n  // JSX can be safely replaced with null because it is unnecessary for styles\n  const nullLiteral = t.nullLiteral();\n\n  // We can do even more\n  // If that JSX is a result of a function, we can replace the function body.\n  const functionScope = getScope(path).getFunctionParent();\n  const scopePath = functionScope?.path;\n  if (scopePath?.isFunction()) {\n    const emptyBody = t.blockStatement([t.returnStatement(nullLiteral)]);\n\n    // Is it not just a function, but a method `render`?\n    if (getFunctionName(scopePath) === 'render') {\n      const decl = scopePath.findParent((p) => p.isClassDeclaration());\n\n      // Replace the whole component\n      if (decl?.isClassDeclaration()) {\n        mutate(decl, (p) => {\n          p.replaceWith(t.functionDeclaration(decl.node.id, [], emptyBody));\n        });\n\n        return;\n      }\n    }\n\n    const body = scopePath.get('body');\n    if (Array.isArray(body)) {\n      throw new Error(\n        \"A body of a function is expected to be a single element but an array was returned. It's possible if JS syntax has been changed since that code was written.\"\n      );\n    }\n\n    const node: typeof scopePath.node = {\n      ...scopePath.node,\n      body: emptyBody,\n      params: [],\n    };\n\n    mutate(scopePath, (p) => {\n      p.replaceWith(node);\n    });\n  } else {\n    mutate(path, (p) => {\n      p.replaceWith(nullLiteral);\n    });\n  }\n}\n"],"mappings":"AAAA,SAASA,KAAK,IAAIC,CAAC,QAAQ,aAAa;AAQxC,SAASC,QAAQ,QAAQ,aAAa;AACtC,SAASC,MAAM,QAAQ,iBAAiB;AAExC,SAASC,eAAe,CAACC,IAA4B,EAAiB;EACpE,IAAIA,IAAI,CAACC,aAAa,EAAE,IAAIL,CAAC,CAACM,YAAY,CAACF,IAAI,CAACG,IAAI,CAACC,GAAG,CAAC,EAAE;IACzD,OAAOJ,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,IAAI;EAC3B;EAEA,OAAO,IAAI;AACb;AAEA,eAAe,SAASC,kBAAkB,CACxCN,IAAoC,EACpC;EACA;EACA,MAAMO,WAAW,GAAGX,CAAC,CAACW,WAAW,EAAE;;EAEnC;EACA;EACA,MAAMC,aAAa,GAAGX,QAAQ,CAACG,IAAI,CAAC,CAACS,iBAAiB,EAAE;EACxD,MAAMC,SAAS,GAAGF,aAAa,EAAER,IAAI;EACrC,IAAIU,SAAS,EAAEC,UAAU,EAAE,EAAE;IAC3B,MAAMC,SAAS,GAAGhB,CAAC,CAACiB,cAAc,CAAC,CAACjB,CAAC,CAACkB,eAAe,CAACP,WAAW,CAAC,CAAC,CAAC;;IAEpE;IACA,IAAIR,eAAe,CAACW,SAAS,CAAC,KAAK,QAAQ,EAAE;MAC3C,MAAMK,IAAI,GAAGL,SAAS,CAACM,UAAU,CAAEC,CAAC,IAAKA,CAAC,CAACC,kBAAkB,EAAE,CAAC;;MAEhE;MACA,IAAIH,IAAI,EAAEG,kBAAkB,EAAE,EAAE;QAC9BpB,MAAM,CAACiB,IAAI,EAAGE,CAAC,IAAK;UAClBA,CAAC,CAACE,WAAW,CAACvB,CAAC,CAACwB,mBAAmB,CAACL,IAAI,CAACZ,IAAI,CAACkB,EAAE,EAAE,EAAE,EAAET,SAAS,CAAC,CAAC;QACnE,CAAC,CAAC;QAEF;MACF;IACF;IAEA,MAAMU,IAAI,GAAGZ,SAAS,CAACa,GAAG,CAAC,MAAM,CAAC;IAClC,IAAIC,KAAK,CAACC,OAAO,CAACH,IAAI,CAAC,EAAE;MACvB,MAAM,IAAII,KAAK,CACb,6JAA6J,CAC9J;IACH;IAEA,MAAMvB,IAA2B,GAAG;MAClC,GAAGO,SAAS,CAACP,IAAI;MACjBmB,IAAI,EAAEV,SAAS;MACfe,MAAM,EAAE;IACV,CAAC;IAED7B,MAAM,CAACY,SAAS,EAAGO,CAAC,IAAK;MACvBA,CAAC,CAACE,WAAW,CAAChB,IAAI,CAAC;IACrB,CAAC,CAAC;EACJ,CAAC,MAAM;IACLL,MAAM,CAACE,IAAI,EAAGiB,CAAC,IAAK;MAClBA,CAAC,CAACE,WAAW,CAACZ,WAAW,CAAC;IAC5B,CAAC,CAAC;EACJ;AACF"}