{"version":3,"file":"types.js","names":["ValueType"],"sources":["../src/types.ts"],"sourcesContent":["import type {\n  Expression,\n  Identifier,\n  TemplateElement,\n  MemberExpression,\n  BigIntLiteral,\n  BooleanLiteral,\n  DecimalLiteral,\n  NullLiteral,\n  NumericLiteral,\n  StringLiteral,\n} from '@babel/types';\n\nexport type StyledMeta = {\n  __linaria: {\n    className: string;\n    extends: StyledMeta;\n  };\n};\n\nexport type CSSPropertyValue = string | number;\n\nexport type ObjectWithSelectors = {\n  [key: string]:\n    | ObjectWithSelectors\n    | CSSPropertyValue\n    | (ObjectWithSelectors | CSSPropertyValue)[];\n};\n\nexport type CSSable = ObjectWithSelectors[string];\n\nexport type JSONValue =\n  | null\n  | string\n  | number\n  | boolean\n  | JSONObject\n  | JSONArray;\n\nexport interface JSONObject {\n  [x: string]: JSONValue;\n}\n\nexport type JSONArray = Array<JSONValue>;\n\nexport type Serializable = JSONValue;\n\nexport type Value = (() => void) | StyledMeta | CSSable;\n\nexport type ValueCache = Map<string | number | boolean | null, unknown>;\n\nexport type Artifact = [name: string, data: unknown];\n\nexport type Location = {\n  column: number;\n  line: number;\n};\n\nexport interface ICSSRule {\n  atom?: boolean;\n  className: string;\n  cssText: string;\n  displayName: string;\n  start: Location | null | undefined;\n}\n\nexport interface IInterpolation {\n  id: string;\n  node: Expression;\n  source: string;\n  unit: string;\n}\n\nexport type WrappedNode = string | { node: Identifier; source: string };\n\nexport type Rules = Record<string, ICSSRule>;\n\nexport type CalleeParam = readonly ['callee', Identifier | MemberExpression];\nexport type CallParam = readonly ['call', ...ExpressionValue[]];\nexport type MemberParam = readonly ['member', string];\nexport type TemplateParam = readonly [\n  'template',\n  (TemplateElement | ExpressionValue)[]\n];\n\nexport type Param = CalleeParam | CallParam | MemberParam | TemplateParam;\nexport type Params = readonly Param[];\n\nexport type BuildCodeFrameErrorFn = <TError extends Error>(\n  msg: string,\n  Error?: new (msg: string) => TError\n) => TError;\n\nexport enum ValueType {\n  LAZY,\n  FUNCTION,\n  CONST,\n}\n\nexport type LazyValue = {\n  buildCodeFrameError: BuildCodeFrameErrorFn;\n  ex: Identifier;\n  kind: ValueType.LAZY;\n  source: string;\n};\n\nexport type FunctionValue = {\n  buildCodeFrameError: BuildCodeFrameErrorFn;\n  ex: Identifier;\n  kind: ValueType.FUNCTION;\n  source: string;\n};\n\nexport type ConstValue = {\n  buildCodeFrameError: BuildCodeFrameErrorFn;\n  ex:\n    | StringLiteral\n    | NumericLiteral\n    | NullLiteral\n    | BooleanLiteral\n    | BigIntLiteral\n    | DecimalLiteral;\n  kind: ValueType.CONST;\n  source: string;\n  value: string | number | boolean | null;\n};\n\nexport type ExpressionValue = LazyValue | FunctionValue | ConstValue;\n\nexport type Replacements = Array<{\n  length: number;\n  original: {\n    end: Location;\n    start: Location;\n  };\n}>;\n"],"mappings":";;;;;;IA6FYA,SAAS;AAAA;AAAA,WAATA,SAAS;EAATA,SAAS,CAATA,SAAS;EAATA,SAAS,CAATA,SAAS;EAATA,SAAS,CAATA,SAAS;AAAA,GAATA,SAAS,yBAATA,SAAS"}