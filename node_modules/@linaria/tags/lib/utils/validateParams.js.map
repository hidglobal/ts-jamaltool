{"version":3,"file":"validateParams.js","names":["isValidParams","params","constraints","i","length","constraint","undefined","Array","isArray","every","c","validateParams","messageOrError","Error"],"sources":["../../src/utils/validateParams.ts"],"sourcesContent":["import type { Param, Params } from '../types';\n\ntype ParamName = Param[0];\ntype ParamConstraint = ParamName | [...ParamName[]] | '*';\n\nexport type ParamConstraints =\n  | [...ParamConstraint[]]\n  | [...ParamConstraint[], '...'];\n\n// ParamMapping maps each ParamName to its corresponding Param type.\ntype ParamMapping = {\n  [K in ParamName]: Extract<Param, readonly [K, ...unknown[]]>; // For each ParamName K, extract the corresponding Param type.\n};\n\n// GetParamByName returns the Param type based on the input type T.\ntype GetParamByName<T> = T extends '*'\n  ? Param // If T is '*', return Param type.\n  : T extends keyof ParamMapping // If T is a key in ParamMapping (i.e., a ParamName).\n  ? ParamMapping[T] // Return the corresponding Param type from ParamMapping.\n  : T extends Array<infer TNames> // If T is an array of names.\n  ? TNames extends ParamName // If TNames is a ParamName.\n    ? Extract<Param, readonly [TNames, ...unknown[]]> // Return the corresponding Param type.\n    : never // If TNames is not a ParamName, return never.\n  : never; // If T is none of the above, return never.\n\n// MapParams iteratively maps the input ParamConstraints to their corresponding Param types.\nexport type MapParams<\n  TNames extends ParamConstraints,\n  TRes extends Param[] = []\n> = TNames extends [infer THead, ...infer TTail] // If TNames is a non-empty tuple.\n  ? THead extends '...' // If the first element in the tuple is '...'.\n    ? [...TRes, ...Params] // Append all Params to the result tuple.\n    : MapParams<\n        Extract<TTail, ParamConstraints>, // Extract the remaining ParamConstraints.\n        [...TRes, GetParamByName<Extract<THead, ParamName | '*' | ParamName[]>>] // Append the mapped Param to the result tuple and recurse.\n      >\n  : TRes; // If TNames is an empty tuple, return the result tuple.\n\nexport function isValidParams<T extends ParamConstraints>(\n  params: Params,\n  constraints: T\n): params is MapParams<T> {\n  for (let i = 0; i < constraints.length; i++) {\n    const constraint = constraints[i];\n    if (constraint === '...') {\n      return true;\n    }\n\n    if (constraint === '*') {\n      if (params[i] === undefined) {\n        return false;\n      }\n    } else if (Array.isArray(constraint)) {\n      if (constraint.every((c) => c !== params[i]?.[0])) {\n        return false;\n      }\n    } else if (constraint !== params[i]?.[0]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function validateParams<T extends ParamConstraints>(\n  params: Params,\n  constraints: T,\n  messageOrError: unknown\n): asserts params is MapParams<T> {\n  if (!isValidParams(params, constraints)) {\n    if (typeof messageOrError === 'string') {\n      throw new Error(messageOrError);\n    }\n\n    throw messageOrError;\n  }\n}\n"],"mappings":";;;;;;;AASA;;AAKA;;AASW;;AAEX;;AAWU;;AAEH,SAASA,aAAa,CAC3BC,MAAc,EACdC,WAAc,EACU;EACxB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,WAAW,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IAAA;IAC3C,MAAME,UAAU,GAAGH,WAAW,CAACC,CAAC,CAAC;IACjC,IAAIE,UAAU,KAAK,KAAK,EAAE;MACxB,OAAO,IAAI;IACb;IAEA,IAAIA,UAAU,KAAK,GAAG,EAAE;MACtB,IAAIJ,MAAM,CAACE,CAAC,CAAC,KAAKG,SAAS,EAAE;QAC3B,OAAO,KAAK;MACd;IACF,CAAC,MAAM,IAAIC,KAAK,CAACC,OAAO,CAACH,UAAU,CAAC,EAAE;MACpC,IAAIA,UAAU,CAACI,KAAK,CAAEC,CAAC;QAAA;QAAA,OAAKA,CAAC,mBAAKT,MAAM,CAACE,CAAC,CAAC,8CAAT,UAAY,CAAC,CAAC;MAAA,EAAC,EAAE;QACjD,OAAO,KAAK;MACd;IACF,CAAC,MAAM,IAAIE,UAAU,oBAAKJ,MAAM,CAACE,CAAC,CAAC,+CAAT,WAAY,CAAC,CAAC,GAAE;MACxC,OAAO,KAAK;IACd;EACF;EAEA,OAAO,IAAI;AACb;AAEO,SAASQ,cAAc,CAC5BV,MAAc,EACdC,WAAc,EACdU,cAAuB,EACS;EAChC,IAAI,CAACZ,aAAa,CAACC,MAAM,EAAEC,WAAW,CAAC,EAAE;IACvC,IAAI,OAAOU,cAAc,KAAK,QAAQ,EAAE;MACtC,MAAM,IAAIC,KAAK,CAACD,cAAc,CAAC;IACjC;IAEA,MAAMA,cAAc;EACtB;AACF"}