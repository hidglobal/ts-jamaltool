{"version":3,"file":"templateProcessor.js","names":["getVariableName","hasMeta","stripLines","throwIfInvalid","toCSS","isCSSable","units","unitRegex","RegExp","join","templateProcessor","tagProcessor","template","valueCache","variableNameConfig","sourceMapReplacements","isReferenced","cssText","item","lastTemplateElementLocation","shift","value","cooked","loc","ex","end","beforeLength","length","next","start","line","column","get","name","isValidValue","bind","source","undefined","__linaria","className","push","original","matches","match","unit","varId","addInterpolation","substring","e","Error","buildCodeFrameError","message","rules","extractRules","location","includes"],"sources":["../../src/utils/templateProcessor.ts"],"sourcesContent":["/* eslint-disable no-continue */\n/**\n * This file handles transforming template literals to class names or styled components and generates CSS content.\n * It uses CSS code from template literals and evaluated values of lazy dependencies stored in ValueCache.\n */\n\nimport type { TemplateElement, SourceLocation } from '@babel/types';\n\nimport type TaggedTemplateProcessor from '../TaggedTemplateProcessor';\nimport type {\n  ExpressionValue,\n  ValueCache,\n  Rules,\n  Replacements,\n} from '../types';\n\nimport { getVariableName } from './getVariableName';\nimport hasMeta from './hasMeta';\nimport stripLines from './stripLines';\nimport throwIfInvalid from './throwIfInvalid';\nimport toCSS, { isCSSable } from './toCSS';\nimport type { IOptions } from './types';\nimport { units } from './units';\n\n// Match any valid CSS units followed by a separator such as ;, newline etc.\nconst unitRegex = new RegExp(`^(?:${units.join('|')})\\\\b`);\n\nexport default function templateProcessor(\n  tagProcessor: TaggedTemplateProcessor,\n  [...template]: (TemplateElement | ExpressionValue)[],\n  valueCache: ValueCache,\n  variableNameConfig: IOptions['variableNameConfig'] | undefined\n): [rules: Rules, sourceMapReplacements: Replacements] | null {\n  const sourceMapReplacements: Replacements = [];\n  // Check if the variable is referenced anywhere for basic DCE\n  // Only works when it's assigned to a variable\n  const { isReferenced } = tagProcessor;\n\n  // Serialize the tagged template literal to a string\n  let cssText = '';\n\n  let item: TemplateElement | ExpressionValue | undefined;\n  let lastTemplateElementLocation: SourceLocation | null | undefined;\n  // eslint-disable-next-line no-cond-assign\n  while ((item = template.shift())) {\n    if ('type' in item) {\n      // It's a template element\n      cssText += item.value.cooked;\n      lastTemplateElementLocation = item.loc;\n      continue;\n    }\n\n    // It's an expression\n    const { ex } = item;\n\n    const { end } = ex.loc!;\n    const beforeLength = cssText.length;\n\n    // The location will be end of the current string to start of next string\n    const next = template[0] as TemplateElement; // template[0] is the next template element\n    const loc = {\n      // +1 because an expression location always shows 1 column before\n      start: {\n        line: lastTemplateElementLocation!.end.line,\n        column: lastTemplateElementLocation!.end.column + 1,\n      },\n      end: next\n        ? { line: next.loc!.start.line, column: next.loc!.start.column }\n        : { line: end.line, column: end.column + 1 },\n    };\n\n    const value = 'value' in item ? item.value : valueCache.get(item.ex.name);\n\n    throwIfInvalid(\n      tagProcessor.isValidValue.bind(tagProcessor),\n      value,\n      item,\n      item.source\n    );\n\n    if (value !== undefined && typeof value !== 'function') {\n      // Skip the blank string instead of throw ing an error\n      if (value === '') {\n        continue;\n      }\n\n      if (hasMeta(value)) {\n        // If it's a React component wrapped in styled, get the class name\n        // Useful for interpolating components\n        cssText += `.${value.__linaria.className}`;\n      } else if (isCSSable(value)) {\n        // If it's a plain object or an array, convert it to a CSS string\n        cssText += stripLines(loc, toCSS(value));\n      } else {\n        // For anything else, assume it'll be stringified\n        cssText += stripLines(loc, value);\n      }\n\n      sourceMapReplacements.push({\n        original: loc,\n        length: cssText.length - beforeLength,\n      });\n    }\n\n    // Is it props based interpolation?\n    if (typeof value === 'function') {\n      // Check if previous expression was a CSS variable that we replaced\n      // If it has a unit after it, we need to move the unit into the interpolation\n      // e.g. `var(--size)px` should actually be `var(--size)`\n      // So we check if the current text starts with a unit, and add the unit to the previous interpolation\n      // Another approach would be `calc(var(--size) * 1px), but some browsers don't support all units\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=956573\n      const matches = next.value.cooked?.match(unitRegex);\n\n      try {\n        if (matches) {\n          template.shift();\n          const [unit] = matches;\n\n          const varId = tagProcessor.addInterpolation(\n            item.ex,\n            cssText,\n            item.source,\n            unit\n          );\n          cssText += getVariableName(varId, variableNameConfig);\n\n          cssText += next.value.cooked?.substring(unit?.length ?? 0) ?? '';\n        } else {\n          const varId = tagProcessor.addInterpolation(\n            item.ex,\n            cssText,\n            item.source\n          );\n          cssText += getVariableName(varId, variableNameConfig);\n        }\n      } catch (e) {\n        if (e instanceof Error) {\n          throw item.buildCodeFrameError(e.message);\n        }\n\n        throw e;\n      }\n    }\n  }\n\n  const rules = tagProcessor.extractRules(\n    valueCache,\n    cssText,\n    tagProcessor.location\n  );\n\n  // tagProcessor.doRuntimeReplacement(classes);\n  if (!isReferenced && !cssText.includes(':global')) {\n    return null;\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  return [rules, sourceMapReplacements];\n}\n"],"mappings":"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"}