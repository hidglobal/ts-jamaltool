{"version":3,"file":"TaggedTemplateProcessor.js","names":["BaseProcessor","templateProcessor","validateParams","TaggedTemplateProcessor","template","constructor","params","args","SKIP","tag","forEach","element","dependencies","push","build","values","artifacts","length","Error","artifact","options","variableNameConfig","toString"],"sources":["../src/TaggedTemplateProcessor.ts"],"sourcesContent":["import type { TemplateElement, Expression, SourceLocation } from '@babel/types';\n\nimport type { TailProcessorParams } from './BaseProcessor';\nimport BaseProcessor from './BaseProcessor';\nimport type { ExpressionValue, ValueCache, Rules, Params } from './types';\nimport templateProcessor from './utils/templateProcessor';\nimport { validateParams } from './utils/validateParams';\n\nexport default abstract class TaggedTemplateProcessor extends BaseProcessor {\n  #template: (TemplateElement | ExpressionValue)[];\n\n  protected constructor(params: Params, ...args: TailProcessorParams) {\n    // Should have at least two params and the first one should be a callee.\n    validateParams(\n      params,\n      ['callee', '*', '...'],\n      TaggedTemplateProcessor.SKIP\n    );\n\n    validateParams(\n      params,\n      ['callee', 'template'],\n      'Invalid usage of template tag'\n    );\n    const [tag, [, template]] = params;\n\n    super([tag], ...args);\n\n    template.forEach((element) => {\n      if ('kind' in element) {\n        this.dependencies.push(element);\n      }\n    });\n\n    this.#template = template;\n  }\n\n  public override build(values: ValueCache) {\n    if (this.artifacts.length > 0) {\n      // FIXME: why it was called twice?\n      throw new Error('Tag is already built');\n    }\n\n    const artifact = templateProcessor(\n      this,\n      this.#template,\n      values,\n      this.options.variableNameConfig\n    );\n    if (artifact) {\n      this.artifacts.push(['css', artifact]);\n    }\n  }\n\n  /**\n   * It is called for each resolved expression in a template literal.\n   * @param node\n   * @param precedingCss\n   * @param source\n   * @param unit\n   * @return chunk of CSS that should be added to extracted CSS\n   */\n  public abstract addInterpolation(\n    node: Expression,\n    precedingCss: string,\n    source: string,\n    unit?: string\n  ): string;\n\n  public abstract extractRules(\n    valueCache: ValueCache,\n    cssText: string,\n    loc?: SourceLocation | null\n  ): Rules;\n\n  public override toString(): string {\n    return `${super.toString()}\\`â€¦\\``;\n  }\n}\n"],"mappings":"AAGA,OAAOA,aAAa,MAAM,iBAAiB;AAE3C,OAAOC,iBAAiB,MAAM,2BAA2B;AACzD,SAASC,cAAc,QAAQ,wBAAwB;AAEvD,eAAe,MAAeC,uBAAuB,SAASH,aAAa,CAAC;EAC1E,CAACI,QAAQ;EAECC,WAAW,CAACC,MAAc,EAAE,GAAGC,IAAyB,EAAE;IAClE;IACAL,cAAc,CACZI,MAAM,EACN,CAAC,QAAQ,EAAE,GAAG,EAAE,KAAK,CAAC,EACtBH,uBAAuB,CAACK,IAAI,CAC7B;IAEDN,cAAc,CACZI,MAAM,EACN,CAAC,QAAQ,EAAE,UAAU,CAAC,EACtB,+BAA+B,CAChC;IACD,MAAM,CAACG,GAAG,EAAE,GAAGL,QAAQ,CAAC,CAAC,GAAGE,MAAM;IAElC,KAAK,CAAC,CAACG,GAAG,CAAC,EAAE,GAAGF,IAAI,CAAC;IAErBH,QAAQ,CAACM,OAAO,CAAEC,OAAO,IAAK;MAC5B,IAAI,MAAM,IAAIA,OAAO,EAAE;QACrB,IAAI,CAACC,YAAY,CAACC,IAAI,CAACF,OAAO,CAAC;MACjC;IACF,CAAC,CAAC;IAEF,IAAI,CAAC,CAACP,QAAQ,GAAGA,QAAQ;EAC3B;EAEgBU,KAAK,CAACC,MAAkB,EAAE;IACxC,IAAI,IAAI,CAACC,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;MAC7B;MACA,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;IACzC;IAEA,MAAMC,QAAQ,GAAGlB,iBAAiB,CAChC,IAAI,EACJ,IAAI,CAAC,CAACG,QAAQ,EACdW,MAAM,EACN,IAAI,CAACK,OAAO,CAACC,kBAAkB,CAChC;IACD,IAAIF,QAAQ,EAAE;MACZ,IAAI,CAACH,SAAS,CAACH,IAAI,CAAC,CAAC,KAAK,EAAEM,QAAQ,CAAC,CAAC;IACxC;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAckBG,QAAQ,GAAW;IACjC,OAAQ,GAAE,KAAK,CAACA,QAAQ,EAAG,OAAM;EACnC;AACF"}