{"ast":null,"code":"import { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from '@tiptap/pm/state';\nimport { EditorView } from '@tiptap/pm/view';\nimport { keymap } from '@tiptap/pm/keymap';\nimport { Schema, Fragment, DOMParser, DOMSerializer, Node as Node$1, Slice } from '@tiptap/pm/model';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, Transform, canSplit, canJoin, findWrapping } from '@tiptap/pm/transform';\nimport { createParagraphNear as createParagraphNear$1, deleteSelection as deleteSelection$1, exitCode as exitCode$1, joinUp as joinUp$1, joinDown as joinDown$1, joinBackward as joinBackward$1, joinForward as joinForward$1, lift as lift$1, liftEmptyBlock as liftEmptyBlock$1, newlineInCode as newlineInCode$1, selectNodeBackward as selectNodeBackward$1, selectNodeForward as selectNodeForward$1, selectParentNode as selectParentNode$1, selectTextblockEnd as selectTextblockEnd$1, selectTextblockStart as selectTextblockStart$1, setBlockType, wrapIn as wrapIn$1 } from '@tiptap/pm/commands';\nimport { liftListItem as liftListItem$1, sinkListItem as sinkListItem$1, wrapInList as wrapInList$1 } from '@tiptap/pm/schema-list';\nfunction createChainableState(config) {\n  const {\n    state,\n    transaction\n  } = config;\n  let {\n    selection\n  } = transaction;\n  let {\n    doc\n  } = transaction;\n  let {\n    storedMarks\n  } = transaction;\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks;\n    },\n    get selection() {\n      return selection;\n    },\n    get doc() {\n      return doc;\n    },\n    get tr() {\n      selection = transaction.selection;\n      doc = transaction.doc;\n      storedMarks = transaction.storedMarks;\n      return transaction;\n    }\n  };\n}\nclass CommandManager {\n  constructor(props) {\n    this.editor = props.editor;\n    this.rawCommands = this.editor.extensionManager.commands;\n    this.customState = props.state;\n  }\n  get hasCustomState() {\n    return !!this.customState;\n  }\n  get state() {\n    return this.customState || this.editor.state;\n  }\n  get commands() {\n    var _this = this;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const {\n      tr\n    } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(Object.entries(rawCommands).map(_ref => {\n      let [name, command] = _ref;\n      const method = function () {\n        const callback = command(...arguments)(props);\n        if (!tr.getMeta('preventDispatch') && !_this.hasCustomState) {\n          view.dispatch(tr);\n        }\n        return callback;\n      };\n      return [name, method];\n    }));\n  }\n  get chain() {\n    return () => this.createChain();\n  }\n  get can() {\n    return () => this.createCan();\n  }\n  createChain(startTr) {\n    var _this2 = this;\n    let shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n    const run = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch') && !this.hasCustomState) {\n        view.dispatch(tr);\n      }\n      return callbacks.every(callback => callback === true);\n    };\n    const chain = {\n      ...Object.fromEntries(Object.entries(rawCommands).map(_ref2 => {\n        let [name, command] = _ref2;\n        const chainedCommand = function () {\n          const props = _this2.buildProps(tr, shouldDispatch);\n          const callback = command(...arguments)(props);\n          callbacks.push(callback);\n          return chain;\n        };\n        return [name, chainedCommand];\n      })),\n      run\n    };\n    return chain;\n  }\n  createCan(startTr) {\n    const {\n      rawCommands,\n      state\n    } = this;\n    const dispatch = false;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(_ref3 => {\n      let [name, command] = _ref3;\n      return [name, function () {\n        return command(...arguments)({\n          ...props,\n          dispatch: undefined\n        });\n      }];\n    }));\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch)\n    };\n  }\n  buildProps(tr) {\n    let shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    if (state.storedMarks) {\n      tr.setStoredMarks(state.storedMarks);\n    }\n    const props = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(Object.entries(rawCommands).map(_ref4 => {\n          let [name, command] = _ref4;\n          return [name, function () {\n            return command(...arguments)(props);\n          }];\n        }));\n      }\n    };\n    return props;\n  }\n}\nclass EventEmitter {\n  constructor() {\n    this.callbacks = {};\n  }\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n    this.callbacks[event].push(fn);\n    return this;\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args));\n    }\n    return this;\n  }\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n    return this;\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n}\nfunction getExtensionField(extension, field, context) {\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    });\n    return value;\n  }\n  return extension.config[field];\n}\nfunction splitExtensions(extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension');\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node');\n  const markExtensions = extensions.filter(extension => extension.type === 'mark');\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\n\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\nfunction getAttributesFromExtensions(extensions) {\n  const extensionAttributes = [];\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false\n  };\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n    if (!addGlobalAttributes) {\n      return;\n    }\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object.entries(globalAttribute.attributes).forEach(_ref5 => {\n          let [name, attribute] = _ref5;\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: {\n              ...defaultAttribute,\n              ...attribute\n            }\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addAttributes = getExtensionField(extension, 'addAttributes', context);\n    if (!addAttributes) {\n      return;\n    }\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(_ref6 => {\n      let [name, attribute] = _ref6;\n      const mergedAttr = {\n        ...defaultAttribute,\n        ...attribute\n      };\n      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === 'function') {\n        mergedAttr.default = mergedAttr.default();\n      }\n      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === undefined) {\n        delete mergedAttr.default;\n      }\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr\n      });\n    });\n  });\n  return extensionAttributes;\n}\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.nodes[nameOrType];\n  }\n  return nameOrType;\n}\nfunction mergeAttributes() {\n  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    objects[_key2] = arguments[_key2];\n  }\n  return objects.filter(item => !!item).reduce((items, item) => {\n    const mergedAttributes = {\n      ...items\n    };\n    Object.entries(item).forEach(_ref7 => {\n      let [key, value] = _ref7;\n      const exists = mergedAttributes[key];\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n      if (key === 'class') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join(' ');\n      } else if (key === 'style') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter(item => item.attribute.rendered).map(item => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\nfunction callOrReturn(value) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  if (isFunction(value)) {\n    for (var _len3 = arguments.length, props = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      props[_key3 - 2] = arguments[_key3];\n    }\n    if (context) {\n      return value.bind(context)(...props);\n    }\n    return value(...props);\n  }\n  return value;\n}\nfunction isEmptyObject() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.keys(value).length === 0 && value.constructor === Object;\n}\nfunction fromString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value);\n  }\n  if (value === 'true') {\n    return true;\n  }\n  if (value === 'false') {\n    return false;\n  }\n  return value;\n}\n\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (parseRule.style) {\n    return parseRule;\n  }\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n      if (oldAttributes === false) {\n        return false;\n      }\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n        if (value === null || value === undefined) {\n          return items;\n        }\n        return {\n          ...items,\n          [item.name]: value\n        };\n      }, {});\n      return {\n        ...oldAttributes,\n        ...newAttributes\n      };\n    }\n  };\n}\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(\n  // @ts-ignore\n  Object.entries(data).filter(_ref8 => {\n    let [key, value] = _ref8;\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false;\n    }\n    return value !== null && value !== undefined;\n  }));\n}\nfunction getSchemaByResolvedExtensions(extensions, editor) {\n  var _a;\n  const allAttributes = getAttributesFromExtensions(extensions);\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\n  const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      editor\n    };\n    const extraNodeFields = extensions.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n      return {\n        ...fields,\n        ...(extendNodeSchema ? extendNodeSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({\n      ...extraNodeFields,\n      content: callOrReturn(getExtensionField(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n    if (renderHTML) {\n      schema.toDOM = node => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n      });\n    }\n    const renderText = getExtensionField(extension, 'renderText', context);\n    if (renderText) {\n      schema.toText = renderText;\n    }\n    return [extension.name, schema];\n  }));\n  const marks = Object.fromEntries(markExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      editor\n    };\n    const extraMarkFields = extensions.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n      return {\n        ...fields,\n        ...(extendMarkSchema ? extendMarkSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({\n      ...extraMarkFields,\n      inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n    if (renderHTML) {\n      schema.toDOM = mark => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n      });\n    }\n    return [extension.name, schema];\n  }));\n  return new Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\nfunction getSchemaTypeByName(name, schema) {\n  return schema.nodes[name] || schema.marks[name] || null;\n}\nfunction isExtensionRulesEnabled(extension, enabled) {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string' ? enabledExtension : enabledExtension.name;\n      return name === extension.name;\n    });\n  }\n  return enabled;\n}\nconst getTextContentFromNodes = function ($from) {\n  let maxMatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  let textBefore = '';\n  const sliceEndPos = $from.parentOffset;\n  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n    var _a, _b;\n    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n      node,\n      pos,\n      parent,\n      index\n    })) || node.textContent || '%leaf%';\n    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));\n  });\n  return textBefore;\n};\nfunction isRegExp(value) {\n  return Object.prototype.toString.call(value) === '[object RegExp]';\n}\nclass InputRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst inputRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return find.exec(text);\n  }\n  const inputRuleMatch = find(text);\n  if (!inputRuleMatch) {\n    return null;\n  }\n  const result = [inputRuleMatch.text];\n  result.index = inputRuleMatch.index;\n  result.input = text;\n  result.data = inputRuleMatch.data;\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n    }\n    result.push(inputRuleMatch.replaceWith);\n  }\n  return result;\n};\nfunction run$1(config) {\n  var _a;\n  const {\n    editor,\n    from,\n    to,\n    text,\n    rules,\n    plugin\n  } = config;\n  const {\n    view\n  } = editor;\n  if (view.composing) {\n    return false;\n  }\n  const $from = view.state.doc.resolve(from);\n  if (\n  // check for code node\n  $from.parent.type.spec.code\n  // check for code mark\n  || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\n    return false;\n  }\n  let matched = false;\n  const textBefore = getTextContentFromNodes($from) + text;\n  rules.forEach(rule => {\n    if (matched) {\n      return;\n    }\n    const match = inputRuleMatcherHandler(textBefore, rule.find);\n    if (!match) {\n      return;\n    }\n    const tr = view.state.tr;\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr\n    });\n    const range = {\n      from: from - (match[0].length - text.length),\n      to\n    };\n    const {\n      commands,\n      chain,\n      can\n    } = new CommandManager({\n      editor,\n      state\n    });\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can\n    });\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return;\n    }\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    });\n    view.dispatch(tr);\n    matched = true;\n  });\n  return matched;\n}\n/**\r\n * Create an input rules plugin. When enabled, it will cause text\r\n * input that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\nfunction inputRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin);\n        if (stored) {\n          return stored;\n        }\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run$1({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin\n        });\n      },\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const {\n              $cursor\n            } = view.state.selection;\n            if ($cursor) {\n              run$1({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin\n              });\n            }\n          });\n          return false;\n        }\n      },\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false;\n        }\n        const {\n          $cursor\n        } = view.state.selection;\n        if ($cursor) {\n          return run$1({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin\n          });\n        }\n        return false;\n      }\n    },\n    // @ts-ignore\n    isInputRules: true\n  });\n  return plugin;\n}\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\nclass PasteRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst pasteRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)];\n  }\n  const matches = find(text);\n  if (!matches) {\n    return [];\n  }\n  return matches.map(pasteRuleMatch => {\n    const result = [pasteRuleMatch.text];\n    result.index = pasteRuleMatch.index;\n    result.input = text;\n    result.data = pasteRuleMatch.data;\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n      }\n      result.push(pasteRuleMatch.replaceWith);\n    }\n    return result;\n  });\n};\nfunction run(config) {\n  const {\n    editor,\n    state,\n    from,\n    to,\n    rule\n  } = config;\n  const {\n    commands,\n    chain,\n    can\n  } = new CommandManager({\n    editor,\n    state\n  });\n  const handlers = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return;\n    }\n    const resolvedFrom = Math.max(from, pos);\n    const resolvedTo = Math.min(to, pos + node.content.size);\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find);\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return;\n      }\n      const start = resolvedFrom + match.index + 1;\n      const end = start + match[0].length;\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end)\n      };\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can\n      });\n      handlers.push(handler);\n    });\n  });\n  const success = handlers.every(handler => handler !== null);\n  return success;\n}\n/**\r\n * Create an paste rules plugin. When enabled, it will cause pasted\r\n * text that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\nfunction pasteRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  let dragSourceElement = null;\n  let isPastedFromProseMirror = false;\n  let isDroppedFromProseMirror = false;\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = event => {\n          var _a;\n          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n        };\n        window.addEventListener('dragstart', handleDragstart);\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart);\n          }\n        };\n      },\n      props: {\n        handleDOMEvents: {\n          drop: view => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n            return false;\n          },\n          paste: (view, event) => {\n            var _a;\n            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\n            return false;\n          }\n        }\n      },\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0];\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\n        if (!isPaste && !isDrop) {\n          return;\n        }\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content);\n        const to = oldState.doc.content.findDiffEnd(state.doc.content);\n        if (!isNumber(from) || !to || from === to.b) {\n          return;\n        }\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr;\n        const chainableState = createChainableState({\n          state,\n          transaction: tr\n        });\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule\n        });\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return;\n        }\n        return tr;\n      }\n    });\n  });\n  return plugins;\n}\nfunction findDuplicates(items) {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n  return [...new Set(filtered)];\n}\nclass ExtensionManager {\n  constructor(extensions, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = ExtensionManager.resolve(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n    this.extensions.forEach(extension => {\n      var _a;\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage;\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      if (extension.type === 'mark') {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n      const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate);\n      }\n      const onCreate = getExtensionField(extension, 'onCreate', context);\n      if (onCreate) {\n        this.editor.on('create', onCreate);\n      }\n      const onUpdate = getExtensionField(extension, 'onUpdate', context);\n      if (onUpdate) {\n        this.editor.on('update', onUpdate);\n      }\n      const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate);\n      }\n      const onTransaction = getExtensionField(extension, 'onTransaction', context);\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction);\n      }\n      const onFocus = getExtensionField(extension, 'onFocus', context);\n      if (onFocus) {\n        this.editor.on('focus', onFocus);\n      }\n      const onBlur = getExtensionField(extension, 'onBlur', context);\n      if (onBlur) {\n        this.editor.on('blur', onBlur);\n      }\n      const onDestroy = getExtensionField(extension, 'onDestroy', context);\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy);\n      }\n    });\n  }\n  static resolve(extensions) {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\n    if (duplicatedNames.length) {\n      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map(item => `'${item}'`).join(', ')}]. This can lead to issues.`);\n    }\n    return resolvedExtensions;\n  }\n  static flatten(extensions) {\n    return extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n      };\n      const addExtensions = getExtensionField(extension, 'addExtensions', context);\n      if (addExtensions) {\n        return [extension, ...this.flatten(addExtensions())];\n      }\n      return extension;\n    })\n    // `Infinity` will break TypeScript so we set a number that is probably high enough\n    .flat(10);\n  }\n  static sort(extensions) {\n    const defaultPriority = 100;\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField(a, 'priority') || defaultPriority;\n      const priorityB = getExtensionField(b, 'priority') || defaultPriority;\n      if (priorityA > priorityB) {\n        return -1;\n      }\n      if (priorityA < priorityB) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  get commands() {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, 'addCommands', context);\n      if (!addCommands) {\n        return commands;\n      }\n      return {\n        ...commands,\n        ...addCommands()\n      };\n    }, {});\n  }\n  get plugins() {\n    const {\n      editor\n    } = this;\n    // With ProseMirror, first plugins within an array are executed first.\n    // In Tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse());\n    const inputRules = [];\n    const pasteRules = [];\n    const allPlugins = extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n      let defaultBindings = {};\n      // bind exit handling\n      if (extension.type === 'mark' && extension.config.exitable) {\n        defaultBindings.ArrowRight = () => Mark.handleExit({\n          editor,\n          mark: extension\n        });\n      }\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(_ref9 => {\n          let [shortcut, method] = _ref9;\n          return [shortcut, () => method({\n            editor\n          })];\n        }));\n        defaultBindings = {\n          ...defaultBindings,\n          ...bindings\n        };\n      }\n      const keyMapPlugin = keymap(defaultBindings);\n      plugins.push(keyMapPlugin);\n      const addInputRules = getExtensionField(extension, 'addInputRules', context);\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        inputRules.push(...addInputRules());\n      }\n      const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        pasteRules.push(...addPasteRules());\n      }\n      const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n      return plugins;\n    }).flat();\n    return [inputRulesPlugin({\n      editor,\n      rules: inputRules\n    }), ...pasteRulesPlugin({\n      editor,\n      rules: pasteRules\n    }), ...allPlugins];\n  }\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n  get nodeViews() {\n    const {\n      editor\n    } = this;\n    const {\n      nodeExtensions\n    } = splitExtensions(this.extensions);\n    return Object.fromEntries(nodeExtensions.filter(extension => !!getExtensionField(extension, 'addNodeView')).map(extension => {\n      const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getNodeType(extension.name, this.schema)\n      };\n      const addNodeView = getExtensionField(extension, 'addNodeView', context);\n      if (!addNodeView) {\n        return [];\n      }\n      const nodeview = (node, view, getPos, decorations) => {\n        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n        return addNodeView()({\n          editor,\n          node,\n          getPos,\n          decorations,\n          HTMLAttributes,\n          extension\n        });\n      };\n      return [extension.name, nodeview];\n    }));\n  }\n}\n\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n  if (getType(value) !== 'Object') {\n    return false;\n  }\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction mergeDeep(target, source) {\n  const output = {\n    ...target\n  };\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, {\n          [key]: source[key]\n        });\n      }\n    });\n  }\n  return output;\n}\nclass Extension {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'extension';\n    this.name = 'extension';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Extension(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Extension(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nfunction getTextBetween(startNode, range, options) {\n  const {\n    from,\n    to\n  } = range;\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  let text = '';\n  let separated = true;\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    var _a;\n    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator;\n        separated = true;\n      }\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range\n        });\n      }\n    } else if (node.isText) {\n      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n      separated = false;\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator;\n      separated = true;\n    }\n  });\n  return text;\n}\nfunction getTextSerializersFromSchema(schema) {\n  return Object.fromEntries(Object.entries(schema.nodes).filter(_ref10 => {\n    let [, node] = _ref10;\n    return node.spec.toText;\n  }).map(_ref11 => {\n    let [name, node] = _ref11;\n    return [name, node.spec.toText];\n  }));\n}\nconst ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('clipboardTextSerializer'),\n      props: {\n        clipboardTextSerializer: () => {\n          const {\n            editor\n          } = this;\n          const {\n            state,\n            schema\n          } = editor;\n          const {\n            doc,\n            selection\n          } = state;\n          const {\n            ranges\n          } = selection;\n          const from = Math.min(...ranges.map(range => range.$from.pos));\n          const to = Math.max(...ranges.map(range => range.$to.pos));\n          const textSerializers = getTextSerializersFromSchema(schema);\n          const range = {\n            from,\n            to\n          };\n          return getTextBetween(doc, range, {\n            textSerializers\n          });\n        }\n      }\n    })];\n  }\n});\nconst blur = () => _ref12 => {\n  let {\n    editor,\n    view\n  } = _ref12;\n  requestAnimationFrame(() => {\n    var _a;\n    if (!editor.isDestroyed) {\n      view.dom.blur();\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n    }\n  });\n  return true;\n};\nconst clearContent = function () {\n  let emitUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return _ref13 => {\n    let {\n      commands\n    } = _ref13;\n    return commands.setContent('', emitUpdate);\n  };\n};\nconst clearNodes = () => _ref14 => {\n  let {\n    state,\n    tr,\n    dispatch\n  } = _ref14;\n  const {\n    selection\n  } = tr;\n  const {\n    ranges\n  } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  ranges.forEach(_ref15 => {\n    let {\n      $from,\n      $to\n    } = _ref15;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n      const {\n        doc,\n        mapping\n      } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n      if (!nodeRange) {\n        return;\n      }\n      const targetLiftDepth = liftTarget(nodeRange);\n      if (node.type.isTextblock) {\n        const {\n          defaultType\n        } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\nconst command = fn => props => {\n  return fn(props);\n};\nconst createParagraphNear = () => _ref16 => {\n  let {\n    state,\n    dispatch\n  } = _ref16;\n  return createParagraphNear$1(state, dispatch);\n};\nconst deleteCurrentNode = () => _ref17 => {\n  let {\n    tr,\n    dispatch\n  } = _ref17;\n  const {\n    selection\n  } = tr;\n  const currentNode = selection.$anchor.node();\n  // if there is content inside the current node, break out of this command\n  if (currentNode.content.size > 0) {\n    return false;\n  }\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteNode = typeOrName => _ref18 => {\n  let {\n    tr,\n    state,\n    dispatch\n  } = _ref18;\n  const type = getNodeType(typeOrName, state.schema);\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteRange = range => _ref19 => {\n  let {\n    tr,\n    dispatch\n  } = _ref19;\n  const {\n    from,\n    to\n  } = range;\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n  return true;\n};\nconst deleteSelection = () => _ref20 => {\n  let {\n    state,\n    dispatch\n  } = _ref20;\n  return deleteSelection$1(state, dispatch);\n};\nconst enter = () => _ref21 => {\n  let {\n    commands\n  } = _ref21;\n  return commands.keyboardShortcut('Enter');\n};\nconst exitCode = () => _ref22 => {\n  let {\n    state,\n    dispatch\n  } = _ref22;\n  return exitCode$1(state, dispatch);\n};\n\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\nfunction objectIncludes(object1, object2) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    strict: true\n  };\n  const keys = Object.keys(object2);\n  if (!keys.length) {\n    return true;\n  }\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key];\n    }\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key]);\n    }\n    return object2[key] === object1[key];\n  });\n}\nfunction findMarkInSet(marks, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes);\n  });\n}\nfunction isMarkInSet(marks, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!$pos || !type) {\n    return;\n  }\n  let start = $pos.parent.childAfter($pos.parentOffset);\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset);\n  }\n  if (!start.node) {\n    return;\n  }\n  const mark = findMarkInSet([...start.node.marks], type, attributes);\n  if (!mark) {\n    return;\n  }\n  let startIndex = start.index;\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  findMarkInSet([...start.node.marks], type, attributes);\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.marks[nameOrType];\n  }\n  return nameOrType;\n}\nconst extendMarkRange = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref23 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref23;\n    const type = getMarkType(typeOrName, state.schema);\n    const {\n      doc,\n      selection\n    } = tr;\n    const {\n      $from,\n      from,\n      to\n    } = selection;\n    if (dispatch) {\n      const range = getMarkRange($from, type, attributes);\n      if (range && range.from <= from && range.to >= to) {\n        const newSelection = TextSelection.create(doc, range.from, range.to);\n        tr.setSelection(newSelection);\n      }\n    }\n    return true;\n  };\n};\nconst first = commands => props => {\n  const items = typeof commands === 'function' ? commands(props) : commands;\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n  return false;\n};\nfunction isTextSelection(value) {\n  return value instanceof TextSelection;\n}\nfunction minMax() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return Math.min(Math.max(value, min), max);\n}\nfunction resolveFocusPosition(doc) {\n  let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!position) {\n    return null;\n  }\n  const selectionAtStart = Selection.atStart(doc);\n  const selectionAtEnd = Selection.atEnd(doc);\n  if (position === 'start' || position === true) {\n    return selectionAtStart;\n  }\n  if (position === 'end') {\n    return selectionAtEnd;\n  }\n  const minPos = selectionAtStart.from;\n  const maxPos = selectionAtEnd.to;\n  if (position === 'all') {\n    return TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n  }\n  return TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\nfunction isiOS() {\n  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;\n}\nconst focus = function () {\n  let position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref24 => {\n    let {\n      editor,\n      view,\n      tr,\n      dispatch\n    } = _ref24;\n    options = {\n      scrollIntoView: true,\n      ...options\n    };\n    const delayedFocus = () => {\n      // focus within `requestAnimationFrame` breaks focus on iOS\n      // so we have to call this\n      if (isiOS()) {\n        view.dom.focus();\n      }\n      // For React we have to focus asynchronously. Otherwise wild things happen.\n      // see: https://github.com/ueberdosis/tiptap/issues/1520\n      requestAnimationFrame(() => {\n        if (!editor.isDestroyed) {\n          view.focus();\n          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n            editor.commands.scrollIntoView();\n          }\n        }\n      });\n    };\n    if (view.hasFocus() && position === null || position === false) {\n      return true;\n    }\n    // we don’t try to resolve a NodeSelection or CellSelection\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n      delayedFocus();\n      return true;\n    }\n    // pass through tr.doc instead of editor.state.doc\n    // since transactions could change the editors state before this command has been run\n    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n    const isSameSelection = editor.state.selection.eq(selection);\n    if (dispatch) {\n      if (!isSameSelection) {\n        tr.setSelection(selection);\n      }\n      // `tr.setSelection` resets the stored marks\n      // so we’ll restore them if the selection is the same as before\n      if (isSameSelection && tr.storedMarks) {\n        tr.setStoredMarks(tr.storedMarks);\n      }\n      delayedFocus();\n    }\n    return true;\n  };\n};\nconst forEach = (items, fn) => props => {\n  return items.every((item, index) => fn(item, {\n    ...props,\n    index\n  }));\n};\nconst insertContent = (value, options) => _ref25 => {\n  let {\n    tr,\n    commands\n  } = _ref25;\n  return commands.insertContentAt({\n    from: tr.selection.from,\n    to: tr.selection.to\n  }, value, options);\n};\nfunction elementFromString(value) {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`;\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n}\nfunction createNodeFromContent(content, schema, options) {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options\n  };\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content) && content.length > 0) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\n      }\n      return schema.nodeFromJSON(content);\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n      return createNodeFromContent('', schema, options);\n    }\n  }\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema);\n    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n  }\n  return createNodeFromContent('', schema, options);\n}\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n  if (last < startLen) {\n    return;\n  }\n  const step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return;\n  }\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nconst isFragment = nodeOrFragment => {\n  return nodeOrFragment.toString().startsWith('<');\n};\nconst insertContentAt = (position, value, options) => _ref26 => {\n  let {\n    tr,\n    dispatch,\n    editor\n  } = _ref26;\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options\n    };\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions\n      }\n    });\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true;\n    }\n    let {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    let isOnlyTextContent = true;\n    let isOnlyBlockContent = true;\n    const nodes = isFragment(content) ? content : [content];\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check();\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n    });\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const {\n        parent\n      } = tr.doc.resolve(from);\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n      if (isEmptyTextBlock) {\n        from -= 1;\n        to += 1;\n      }\n    }\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      // if value is string, we can use it directly\n      // otherwise if it is an array, we have to join it\n      if (Array.isArray(value)) {\n        tr.insertText(value.map(v => v.text || '').join(''), from, to);\n      } else if (typeof value === 'object' && !!value && !!value.text) {\n        tr.insertText(value.text, from, to);\n      } else {\n        tr.insertText(value, from, to);\n      }\n    } else {\n      tr.replaceWith(from, to, content);\n    }\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n    }\n  }\n  return true;\n};\nconst joinUp = () => _ref27 => {\n  let {\n    state,\n    dispatch\n  } = _ref27;\n  return joinUp$1(state, dispatch);\n};\nconst joinDown = () => _ref28 => {\n  let {\n    state,\n    dispatch\n  } = _ref28;\n  return joinDown$1(state, dispatch);\n};\nconst joinBackward = () => _ref29 => {\n  let {\n    state,\n    dispatch\n  } = _ref29;\n  return joinBackward$1(state, dispatch);\n};\nconst joinForward = () => _ref30 => {\n  let {\n    state,\n    dispatch\n  } = _ref30;\n  return joinForward$1(state, dispatch);\n};\nfunction isMacOS() {\n  return typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n}\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result === 'Space') {\n    result = ' ';\n  }\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`);\n    }\n  }\n  if (alt) {\n    result = `Alt-${result}`;\n  }\n  if (ctrl) {\n    result = `Ctrl-${result}`;\n  }\n  if (meta) {\n    result = `Meta-${result}`;\n  }\n  if (shift) {\n    result = `Shift-${result}`;\n  }\n  return result;\n}\nconst keyboardShortcut = name => _ref31 => {\n  let {\n    editor,\n    view,\n    tr,\n    dispatch\n  } = _ref31;\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space' ? ' ' : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event));\n  });\n  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\n    const newStep = step.map(tr.mapping);\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\nfunction isNodeActive(state, typeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  const nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return;\n    }\n    const relativeFrom = Math.max(from, pos);\n    const relativeTo = Math.min(to, pos + node.nodeSize);\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo\n    });\n  });\n  const selectionRange = to - from;\n  const matchedNodeRanges = nodeRanges.filter(nodeRange => {\n    if (!type) {\n      return true;\n    }\n    return type.name === nodeRange.node.type.name;\n  }).filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, {\n    strict: false\n  }));\n  if (empty) {\n    return !!matchedNodeRanges.length;\n  }\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n  return range >= selectionRange;\n}\nconst lift = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref32 => {\n    let {\n      state,\n      dispatch\n    } = _ref32;\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (!isActive) {\n      return false;\n    }\n    return lift$1(state, dispatch);\n  };\n};\nconst liftEmptyBlock = () => _ref33 => {\n  let {\n    state,\n    dispatch\n  } = _ref33;\n  return liftEmptyBlock$1(state, dispatch);\n};\nconst liftListItem = typeOrName => _ref34 => {\n  let {\n    state,\n    dispatch\n  } = _ref34;\n  const type = getNodeType(typeOrName, state.schema);\n  return liftListItem$1(type)(state, dispatch);\n};\nconst newlineInCode = () => _ref35 => {\n  let {\n    state,\n    dispatch\n  } = _ref35;\n  return newlineInCode$1(state, dispatch);\n};\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return 'node';\n  }\n  if (schema.marks[name]) {\n    return 'mark';\n  }\n  return null;\n}\n\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n    return newObj;\n  }, {});\n}\nconst resetAttributes = (typeOrName, attributes) => _ref36 => {\n  let {\n    tr,\n    state,\n    dispatch\n  } = _ref36;\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n        }\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n  return true;\n};\nconst scrollIntoView = () => _ref37 => {\n  let {\n    tr,\n    dispatch\n  } = _ref37;\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n  return true;\n};\nconst selectAll = () => _ref38 => {\n  let {\n    tr,\n    commands\n  } = _ref38;\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size\n  });\n};\nconst selectNodeBackward = () => _ref39 => {\n  let {\n    state,\n    dispatch\n  } = _ref39;\n  return selectNodeBackward$1(state, dispatch);\n};\nconst selectNodeForward = () => _ref40 => {\n  let {\n    state,\n    dispatch\n  } = _ref40;\n  return selectNodeForward$1(state, dispatch);\n};\nconst selectParentNode = () => _ref41 => {\n  let {\n    state,\n    dispatch\n  } = _ref41;\n  return selectParentNode$1(state, dispatch);\n};\n\n// @ts-ignore\nconst selectTextblockEnd = () => _ref42 => {\n  let {\n    state,\n    dispatch\n  } = _ref42;\n  return selectTextblockEnd$1(state, dispatch);\n};\n\n// @ts-ignore\nconst selectTextblockStart = () => _ref43 => {\n  let {\n    state,\n    dispatch\n  } = _ref43;\n  return selectTextblockStart$1(state, dispatch);\n};\nfunction createDocument(content, schema) {\n  let parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions\n  });\n}\nconst setContent = function (content) {\n  let emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref44 => {\n    let {\n      tr,\n      editor,\n      dispatch\n    } = _ref44;\n    const {\n      doc\n    } = tr;\n    const document = createDocument(content, editor.schema, parseOptions);\n    if (dispatch) {\n      tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate);\n    }\n    return true;\n  };\n};\n\n/**\r\n * Returns a new `Transform` based on all steps of the passed transactions.\r\n */\nfunction combineTransactionSteps(oldDoc, transactions) {\n  const transform = new Transform(oldDoc);\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step);\n    });\n  });\n  return transform;\n}\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const {\n      type\n    } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n  return null;\n}\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = [];\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\nfunction findParentNode(predicate) {\n  return selection => findParentNodeClosestToPos(selection.$from, predicate);\n}\nfunction getHTMLFromFragment(fragment, schema) {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement('div');\n  container.appendChild(documentFragment);\n  return container.innerHTML;\n}\nfunction getSchema(extensions, editor) {\n  const resolvedExtensions = ExtensionManager.resolve(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\nfunction generateHTML(doc, extensions) {\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode.content, schema);\n}\nfunction generateJSON(html, extensions) {\n  const schema = getSchema(extensions);\n  const dom = elementFromString(html);\n  return DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\nfunction getText(node, options) {\n  const range = {\n    from: 0,\n    to: node.content.size\n  };\n  return getTextBetween(node, range, options);\n}\nfunction generateText(doc, extensions, options) {\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers\n    }\n  });\n}\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const marks = [];\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks);\n    }\n    marks.push(...state.selection.$head.marks());\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks);\n    });\n  }\n  const mark = marks.find(markItem => markItem.type.name === type.name);\n  if (!mark) {\n    return {};\n  }\n  return {\n    ...mark.attrs\n  };\n}\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    from,\n    to\n  } = state.selection;\n  const nodes = [];\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node);\n  });\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n  if (!node) {\n    return {};\n  }\n  return {\n    ...node.attrs\n  };\n}\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName);\n  }\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName);\n  }\n  return {};\n}\n\n/**\r\n * Removes duplicated values within an array.\r\n * Supports numbers, strings and objects.\r\n */\nfunction removeDuplicates(array) {\n  let by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : JSON.stringify;\n  const seen = {};\n  return array.filter(item => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n  });\n}\n\n/**\r\n * Removes duplicated ranges and ranges that are\r\n * fully captured by other ranges.\r\n */\nfunction simplifyChangedRanges(changes) {\n  const uniqueChanges = removeDuplicates(changes);\n  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {\n    const rest = uniqueChanges.filter((_, i) => i !== index);\n    return !rest.some(otherChange => {\n      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n    });\n  });\n}\n/**\r\n * Returns a list of changed ranges\r\n * based on the first and last state of all steps.\r\n */\nfunction getChangedRanges(transform) {\n  const {\n    mapping,\n    steps\n  } = transform;\n  const changes = [];\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges = [];\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const {\n        from,\n        to\n      } = steps[index];\n      if (from === undefined || to === undefined) {\n        return;\n      }\n      ranges.push({\n        from,\n        to\n      });\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({\n          from,\n          to\n        });\n      });\n    }\n    ranges.forEach(_ref45 => {\n      let {\n        from,\n        to\n      } = _ref45;\n      const newStart = mapping.slice(index).map(from, -1);\n      const newEnd = mapping.slice(index).map(to);\n      const oldStart = mapping.invert().map(newStart, -1);\n      const oldEnd = mapping.invert().map(newEnd);\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd\n        }\n      });\n    });\n  });\n  return simplifyChangedRanges(changes);\n}\nfunction getDebugJSON(node) {\n  let startOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const isTopNode = node.type === node.type.schema.topNodeType;\n  const increment = isTopNode ? 0 : 1;\n  const from = startOffset;\n  const to = from + node.nodeSize;\n  const marks = node.marks.map(mark => {\n    const output = {\n      type: mark.type.name\n    };\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = {\n        ...mark.attrs\n      };\n    }\n    return output;\n  });\n  const attrs = {\n    ...node.attrs\n  };\n  const output = {\n    type: node.type.name,\n    from,\n    to\n  };\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs;\n  }\n  if (marks.length) {\n    output.marks = marks;\n  }\n  if (node.content.childCount) {\n    output.content = [];\n    node.forEach((child, offset) => {\n      var _a;\n      (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n    });\n  }\n  if (node.text) {\n    output.text = node.text;\n  }\n  return output;\n}\nfunction getMarksBetween(from, to, doc) {\n  const marks = [];\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc.resolve(from).marks().forEach(mark => {\n      const $pos = doc.resolve(from - 1);\n      const range = getMarkRange($pos, mark.type);\n      if (!range) {\n        return;\n      }\n      marks.push({\n        mark,\n        ...range\n      });\n    });\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(...node.marks.map(mark => ({\n        from: pos,\n        to: pos + node.nodeSize,\n        mark\n      })));\n    });\n  }\n  return marks;\n}\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(Object.entries(attributes).filter(_ref46 => {\n    let [name] = _ref46;\n    const extensionAttribute = extensionAttributes.find(item => {\n      return item.type === typeName && item.name === name;\n    });\n    if (!extensionAttribute) {\n      return false;\n    }\n    return extensionAttribute.attribute.keepOnSplit;\n  }));\n}\nfunction isMarkActive(state, typeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    empty,\n    ranges\n  } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter(mark => {\n      if (!type) {\n        return true;\n      }\n      return type.name === mark.type.name;\n    }).find(mark => objectIncludes(mark.attrs, attributes, {\n      strict: false\n    }));\n  }\n  let selectionRange = 0;\n  const markRanges = [];\n  ranges.forEach(_ref47 => {\n    let {\n      $from,\n      $to\n    } = _ref47;\n    const from = $from.pos;\n    const to = $to.pos;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return;\n      }\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range = relativeTo - relativeFrom;\n      selectionRange += range;\n      markRanges.push(...node.marks.map(mark => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo\n      })));\n    });\n  });\n  if (selectionRange === 0) {\n    return false;\n  }\n  // calculate range of matched mark\n  const matchedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n    return type.name === markRange.mark.type.name;\n  }).filter(markRange => objectIncludes(markRange.mark.attrs, attributes, {\n    strict: false\n  })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\nfunction isActive(state, name) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes);\n  }\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes);\n  }\n  return false;\n}\nfunction isList(name, extensions) {\n  const {\n    nodeExtensions\n  } = splitExtensions(extensions);\n  const extension = nodeExtensions.find(item => item.name === name);\n  if (!extension) {\n    return false;\n  }\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage\n  };\n  const group = callOrReturn(getExtensionField(extension, 'group', context));\n  if (typeof group !== 'string') {\n    return false;\n  }\n  return group.split(' ').includes('list');\n}\nfunction isNodeEmpty(node) {\n  var _a;\n  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n  const content = node.toJSON();\n  return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\nfunction isNodeSelection(value) {\n  return value instanceof NodeSelection;\n}\nfunction posToDOMRect(view, from, to) {\n  const minPos = 0;\n  const maxPos = view.state.doc.content.size;\n  const resolvedFrom = minMax(from, minPos, maxPos);\n  const resolvedEnd = minMax(to, minPos, maxPos);\n  const start = view.coordsAtPos(resolvedFrom);\n  const end = view.coordsAtPos(resolvedEnd, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return {\n    ...data,\n    toJSON: () => data\n  };\n}\nfunction canSetMark(state, tr, newMarkType) {\n  var _a;\n  const {\n    selection\n  } = tr;\n  let cursor = null;\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor;\n  }\n  if (cursor) {\n    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n    // There can be no current marks that exclude the new mark\n    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some(mark => mark.type.excludes(newMarkType));\n  }\n  const {\n    ranges\n  } = selection;\n  return ranges.some(_ref48 => {\n    let {\n      $from,\n      $to\n    } = _ref48;\n    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false;\n      }\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType));\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n      }\n      return !someNodeSupportsMark;\n    });\n    return someNodeSupportsMark;\n  });\n}\nconst setMark = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref49 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref49;\n    const {\n      selection\n    } = tr;\n    const {\n      empty,\n      ranges\n    } = selection;\n    const type = getMarkType(typeOrName, state.schema);\n    if (dispatch) {\n      if (empty) {\n        const oldAttributes = getMarkAttributes(state, type);\n        tr.addStoredMark(type.create({\n          ...oldAttributes,\n          ...attributes\n        }));\n      } else {\n        ranges.forEach(range => {\n          const from = range.$from.pos;\n          const to = range.$to.pos;\n          state.doc.nodesBetween(from, to, (node, pos) => {\n            const trimmedFrom = Math.max(pos, from);\n            const trimmedTo = Math.min(pos + node.nodeSize, to);\n            const someHasMark = node.marks.find(mark => mark.type === type);\n            // if there is already a mark of this type\n            // we know that we have to merge its attributes\n            // otherwise we add a fresh new mark\n            if (someHasMark) {\n              node.marks.forEach(mark => {\n                if (type === mark.type) {\n                  tr.addMark(trimmedFrom, trimmedTo, type.create({\n                    ...mark.attrs,\n                    ...attributes\n                  }));\n                }\n              });\n            } else {\n              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n            }\n          });\n        });\n      }\n    }\n    return canSetMark(state, tr, type);\n  };\n};\nconst setMeta = (key, value) => _ref50 => {\n  let {\n    tr\n  } = _ref50;\n  tr.setMeta(key, value);\n  return true;\n};\nconst setNode = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref51 => {\n    let {\n      state,\n      dispatch,\n      chain\n    } = _ref51;\n    const type = getNodeType(typeOrName, state.schema);\n    // TODO: use a fallback like insertContent?\n    if (!type.isTextblock) {\n      console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n      return false;\n    }\n    return chain()\n    // try to convert node to default node if needed\n    .command(_ref52 => {\n      let {\n        commands\n      } = _ref52;\n      const canSetBlock = setBlockType(type, attributes)(state);\n      if (canSetBlock) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).command(_ref53 => {\n      let {\n        state: updatedState\n      } = _ref53;\n      return setBlockType(type, attributes)(updatedState, dispatch);\n    }).run();\n  };\n};\nconst setNodeSelection = position => _ref54 => {\n  let {\n    tr,\n    dispatch\n  } = _ref54;\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const from = minMax(position, 0, doc.content.size);\n    const selection = NodeSelection.create(doc, from);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst setTextSelection = position => _ref55 => {\n  let {\n    tr,\n    dispatch\n  } = _ref55;\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    const minPos = TextSelection.atStart(doc).from;\n    const maxPos = TextSelection.atEnd(doc).to;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst sinkListItem = typeOrName => _ref56 => {\n  let {\n    state,\n    dispatch\n  } = _ref56;\n  const type = getNodeType(typeOrName, state.schema);\n  return sinkListItem$1(type)(state, dispatch);\n};\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\nconst splitBlock = function () {\n  let {\n    keepMarks = true\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return _ref57 => {\n    let {\n      tr,\n      state,\n      dispatch,\n      editor\n    } = _ref57;\n    const {\n      selection,\n      doc\n    } = tr;\n    const {\n      $from,\n      $to\n    } = selection;\n    const extensionAttributes = editor.extensionManager.attributes;\n    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n      if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n        return false;\n      }\n      if (dispatch) {\n        if (keepMarks) {\n          ensureMarks(state, editor.extensionManager.splittableMarks);\n        }\n        tr.split($from.pos).scrollIntoView();\n      }\n      return true;\n    }\n    if (!$from.parent.isBlock) {\n      return false;\n    }\n    if (dispatch) {\n      const atEnd = $to.parentOffset === $to.parent.content.size;\n      if (selection instanceof TextSelection) {\n        tr.deleteSelection();\n      }\n      const deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n      let types = atEnd && deflt ? [{\n        type: deflt,\n        attrs: newAttributes\n      }] : undefined;\n      let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{\n        type: deflt\n      }] : undefined)) {\n        can = true;\n        types = deflt ? [{\n          type: deflt,\n          attrs: newAttributes\n        }] : undefined;\n      }\n      if (can) {\n        tr.split(tr.mapping.map($from.pos), 1, types);\n        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n          const first = tr.mapping.map($from.before());\n          const $first = tr.doc.resolve(first);\n          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n          }\n        }\n      }\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  };\n};\nconst splitListItem = typeOrName => _ref58 => {\n  let {\n    tr,\n    state,\n    dispatch,\n    editor\n  } = _ref58;\n  var _a;\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    $from,\n    $to\n  } = state.selection;\n  // @ts-ignore\n  // eslint-disable-next-line\n  const node = state.selection.node;\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n  const grandParent = $from.node(-1);\n  if (grandParent.type !== type) {\n    return false;\n  }\n  const extensionAttributes = editor.extensionManager.attributes;\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n    if (dispatch) {\n      let wrap = Fragment.empty;\n      // eslint-disable-next-line\n      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap));\n      }\n      // eslint-disable-next-line\n      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n      const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined));\n      const start = $from.before($from.depth - (depthBefore - 1));\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n      let sel = -1;\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false;\n        }\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1;\n        }\n      });\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  }\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [{\n    type,\n    attrs: newTypeAttributes\n  }, {\n    type: nextType,\n    attrs: newNextTypeAttributes\n  }] : [{\n    type,\n    attrs: newTypeAttributes\n  }];\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n  if (dispatch) {\n    const {\n      selection,\n      storedMarks\n    } = state;\n    const {\n      splittableMarks\n    } = editor.extensionManager;\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    tr.split($from.pos, 2, types).scrollIntoView();\n    if (!marks || !dispatch) {\n      return true;\n    }\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n  }\n  return true;\n};\nconst joinListBackwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n  if (before === undefined) {\n    return true;\n  }\n  const nodeBefore = tr.doc.nodeAt(before);\n  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);\n  if (!canJoinBackwards) {\n    return true;\n  }\n  tr.join(list.pos);\n  return true;\n};\nconst joinListForwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const after = tr.doc.resolve(list.start).after(list.depth);\n  if (after === undefined) {\n    return true;\n  }\n  const nodeAfter = tr.doc.nodeAt(after);\n  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);\n  if (!canJoinForwards) {\n    return true;\n  }\n  tr.join(after);\n  return true;\n};\nconst toggleList = function (listTypeOrName, itemTypeOrName, keepMarks) {\n  let attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return _ref59 => {\n    let {\n      editor,\n      tr,\n      state,\n      dispatch,\n      chain,\n      commands,\n      can\n    } = _ref59;\n    const {\n      extensions,\n      splittableMarks\n    } = editor.extensionManager;\n    const listType = getNodeType(listTypeOrName, state.schema);\n    const itemType = getNodeType(itemTypeOrName, state.schema);\n    const {\n      selection,\n      storedMarks\n    } = state;\n    const {\n      $from,\n      $to\n    } = selection;\n    const range = $from.blockRange($to);\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    if (!range) {\n      return false;\n    }\n    const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n      // remove list\n      if (parentList.node.type === listType) {\n        return commands.liftListItem(itemType);\n      }\n      // change list type\n      if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n        return chain().command(() => {\n          tr.setNodeMarkup(parentList.pos, listType);\n          return true;\n        }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n      }\n    }\n    if (!keepMarks || !marks || !dispatch) {\n      return chain()\n      // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes);\n        if (canWrapInList) {\n          return true;\n        }\n        return commands.clearNodes();\n      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n    }\n    return chain()\n    // try to convert node to default node if needed\n    .command(() => {\n      const canWrapInList = can().wrapInList(listType, attributes);\n      const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n      tr.ensureMarks(filteredMarks);\n      if (canWrapInList) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n  };\n};\nconst toggleMark = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref60 => {\n    let {\n      state,\n      commands\n    } = _ref60;\n    const {\n      extendEmptyMarkRange = false\n    } = options;\n    const type = getMarkType(typeOrName, state.schema);\n    const isActive = isMarkActive(state, type, attributes);\n    if (isActive) {\n      return commands.unsetMark(type, {\n        extendEmptyMarkRange\n      });\n    }\n    return commands.setMark(type, attributes);\n  };\n};\nconst toggleNode = function (typeOrName, toggleTypeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref61 => {\n    let {\n      state,\n      commands\n    } = _ref61;\n    const type = getNodeType(typeOrName, state.schema);\n    const toggleType = getNodeType(toggleTypeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (isActive) {\n      return commands.setNode(toggleType);\n    }\n    return commands.setNode(type, attributes);\n  };\n};\nconst toggleWrap = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref62 => {\n    let {\n      state,\n      commands\n    } = _ref62;\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (isActive) {\n      return commands.lift(type);\n    }\n    return commands.wrapIn(type, attributes);\n  };\n};\nconst undoInputRule = () => _ref63 => {\n  let {\n    state,\n    dispatch\n  } = _ref63;\n  const plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i];\n    let undoable;\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr;\n        const toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst unsetAllMarks = () => _ref64 => {\n  let {\n    tr,\n    dispatch\n  } = _ref64;\n  const {\n    selection\n  } = tr;\n  const {\n    empty,\n    ranges\n  } = selection;\n  if (empty) {\n    return true;\n  }\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos);\n    });\n  }\n  return true;\n};\nconst unsetMark = function (typeOrName) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref65 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref65;\n    var _a;\n    const {\n      extendEmptyMarkRange = false\n    } = options;\n    const {\n      selection\n    } = tr;\n    const type = getMarkType(typeOrName, state.schema);\n    const {\n      $from,\n      empty,\n      ranges\n    } = selection;\n    if (!dispatch) {\n      return true;\n    }\n    if (empty && extendEmptyMarkRange) {\n      let {\n        from,\n        to\n      } = selection;\n      const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n      const range = getMarkRange($from, type, attrs);\n      if (range) {\n        from = range.from;\n        to = range.to;\n      }\n      tr.removeMark(from, to, type);\n    } else {\n      ranges.forEach(range => {\n        tr.removeMark(range.$from.pos, range.$to.pos, type);\n      });\n    }\n    tr.removeStoredMark(type);\n    return true;\n  };\n};\nconst updateAttributes = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref66 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref66;\n    let nodeType = null;\n    let markType = null;\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n    if (!schemaType) {\n      return false;\n    }\n    if (schemaType === 'node') {\n      nodeType = getNodeType(typeOrName, state.schema);\n    }\n    if (schemaType === 'mark') {\n      markType = getMarkType(typeOrName, state.schema);\n    }\n    if (dispatch) {\n      tr.selection.ranges.forEach(range => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          if (nodeType && nodeType === node.type) {\n            tr.setNodeMarkup(pos, undefined, {\n              ...node.attrs,\n              ...attributes\n            });\n          }\n          if (markType && node.marks.length) {\n            node.marks.forEach(mark => {\n              if (markType === mark.type) {\n                const trimmedFrom = Math.max(pos, from);\n                const trimmedTo = Math.min(pos + node.nodeSize, to);\n                tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                  ...mark.attrs,\n                  ...attributes\n                }));\n              }\n            });\n          }\n        });\n      });\n    }\n    return true;\n  };\n};\nconst wrapIn = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref67 => {\n    let {\n      state,\n      dispatch\n    } = _ref67;\n    const type = getNodeType(typeOrName, state.schema);\n    return wrapIn$1(type, attributes)(state, dispatch);\n  };\n};\nconst wrapInList = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref68 => {\n    let {\n      state,\n      dispatch\n    } = _ref68;\n    const type = getNodeType(typeOrName, state.schema);\n    return wrapInList$1(type, attributes)(state, dispatch);\n  };\n};\nvar commands = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur,\n  clearContent: clearContent,\n  clearNodes: clearNodes,\n  command: command,\n  createParagraphNear: createParagraphNear,\n  deleteCurrentNode: deleteCurrentNode,\n  deleteNode: deleteNode,\n  deleteRange: deleteRange,\n  deleteSelection: deleteSelection,\n  enter: enter,\n  exitCode: exitCode,\n  extendMarkRange: extendMarkRange,\n  first: first,\n  focus: focus,\n  forEach: forEach,\n  insertContent: insertContent,\n  insertContentAt: insertContentAt,\n  joinUp: joinUp,\n  joinDown: joinDown,\n  joinBackward: joinBackward,\n  joinForward: joinForward,\n  keyboardShortcut: keyboardShortcut,\n  lift: lift,\n  liftEmptyBlock: liftEmptyBlock,\n  liftListItem: liftListItem,\n  newlineInCode: newlineInCode,\n  resetAttributes: resetAttributes,\n  scrollIntoView: scrollIntoView,\n  selectAll: selectAll,\n  selectNodeBackward: selectNodeBackward,\n  selectNodeForward: selectNodeForward,\n  selectParentNode: selectParentNode,\n  selectTextblockEnd: selectTextblockEnd,\n  selectTextblockStart: selectTextblockStart,\n  setContent: setContent,\n  setMark: setMark,\n  setMeta: setMeta,\n  setNode: setNode,\n  setNodeSelection: setNodeSelection,\n  setTextSelection: setTextSelection,\n  sinkListItem: sinkListItem,\n  splitBlock: splitBlock,\n  splitListItem: splitListItem,\n  toggleList: toggleList,\n  toggleMark: toggleMark,\n  toggleNode: toggleNode,\n  toggleWrap: toggleWrap,\n  undoInputRule: undoInputRule,\n  unsetAllMarks: unsetAllMarks,\n  unsetMark: unsetMark,\n  updateAttributes: updateAttributes,\n  wrapIn: wrapIn,\n  wrapInList: wrapInList\n});\nconst Commands = Extension.create({\n  name: 'commands',\n  addCommands() {\n    return {\n      ...commands\n    };\n  }\n});\nconst Editable = Extension.create({\n  name: 'editable',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('editable'),\n      props: {\n        editable: () => this.editor.options.editable\n      }\n    })];\n  }\n});\nconst FocusEvents = Extension.create({\n  name: 'focusEvents',\n  addProseMirrorPlugins() {\n    const {\n      editor\n    } = this;\n    return [new Plugin({\n      key: new PluginKey('focusEvents'),\n      props: {\n        handleDOMEvents: {\n          focus: (view, event) => {\n            editor.isFocused = true;\n            const transaction = editor.state.tr.setMeta('focus', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          },\n          blur: (view, event) => {\n            editor.isFocused = false;\n            const transaction = editor.state.tr.setMeta('blur', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          }\n        }\n      }\n    })];\n  }\n});\nconst Keymap = Extension.create({\n  name: 'keymap',\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(_ref69 => {\n      let {\n        commands\n      } = _ref69;\n      return [() => commands.undoInputRule(),\n      // maybe convert first text block node to default node\n      () => commands.command(_ref70 => {\n        let {\n          tr\n        } = _ref70;\n        const {\n          selection,\n          doc\n        } = tr;\n        const {\n          empty,\n          $anchor\n        } = selection;\n        const {\n          pos,\n          parent\n        } = $anchor;\n        const isAtStart = Selection.atStart(doc).from === pos;\n        if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n          return false;\n        }\n        return commands.clearNodes();\n      }), () => commands.deleteSelection(), () => commands.joinBackward(), () => commands.selectNodeBackward()];\n    });\n    const handleDelete = () => this.editor.commands.first(_ref71 => {\n      let {\n        commands\n      } = _ref71;\n      return [() => commands.deleteSelection(), () => commands.deleteCurrentNode(), () => commands.joinForward(), () => commands.selectNodeForward()];\n    });\n    const handleEnter = () => this.editor.commands.first(_ref72 => {\n      let {\n        commands\n      } = _ref72;\n      return [() => commands.newlineInCode(), () => commands.createParagraphNear(), () => commands.liftEmptyBlock(), () => commands.splitBlock()];\n    });\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll()\n    };\n    const pcKeymap = {\n      ...baseKeymap\n    };\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd()\n    };\n    if (isiOS() || isMacOS()) {\n      return macKeymap;\n    }\n    return pcKeymap;\n  },\n  addProseMirrorPlugins() {\n    return [\n    // With this plugin we check if the whole document was selected and deleted.\n    // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n    // to a paragraph if necessary.\n    // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n    // with many other commands.\n    new Plugin({\n      key: new PluginKey('clearDocument'),\n      appendTransaction: (transactions, oldState, newState) => {\n        const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n        if (!docChanges) {\n          return;\n        }\n        const {\n          empty,\n          from,\n          to\n        } = oldState.selection;\n        const allFrom = Selection.atStart(oldState.doc).from;\n        const allEnd = Selection.atEnd(oldState.doc).to;\n        const allWasSelected = from === allFrom && to === allEnd;\n        if (empty || !allWasSelected) {\n          return;\n        }\n        const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;\n        if (!isEmpty) {\n          return;\n        }\n        const tr = newState.tr;\n        const state = createChainableState({\n          state: newState,\n          transaction: tr\n        });\n        const {\n          commands\n        } = new CommandManager({\n          editor: this.editor,\n          state\n        });\n        commands.clearNodes();\n        if (!tr.steps.length) {\n          return;\n        }\n        return tr;\n      }\n    })];\n  }\n});\nconst Tabindex = Extension.create({\n  name: 'tabindex',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('tabindex'),\n      props: {\n        attributes: this.editor.isEditable ? {\n          tabindex: '0'\n        } : {}\n      }\n    })];\n  }\n});\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Tabindex: Tabindex\n});\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\nfunction createStyleTag(style, nonce) {\n  const tiptapStyleTag = document.querySelector('style[data-tiptap-style]');\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag;\n  }\n  const styleNode = document.createElement('style');\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce);\n  }\n  styleNode.setAttribute('data-tiptap-style', '');\n  styleNode.innerHTML = style;\n  document.getElementsByTagName('head')[0].appendChild(styleNode);\n  return styleNode;\n}\nclass Editor extends EventEmitter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.isFocused = false;\n    this.extensionStorage = {};\n    this.options = {\n      element: document.createElement('div'),\n      content: '',\n      injectCSS: true,\n      injectNonce: undefined,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      enableCoreExtensions: true,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on('beforeCreate', this.options.onBeforeCreate);\n    this.emit('beforeCreate', {\n      editor: this\n    });\n    this.createView();\n    this.injectCSS();\n    this.on('create', this.options.onCreate);\n    this.on('update', this.options.onUpdate);\n    this.on('selectionUpdate', this.options.onSelectionUpdate);\n    this.on('transaction', this.options.onTransaction);\n    this.on('focus', this.options.onFocus);\n    this.on('blur', this.options.onBlur);\n    this.on('destroy', this.options.onDestroy);\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n      this.commands.focus(this.options.autofocus);\n      this.emit('create', {\n        editor: this\n      });\n    }, 0);\n  }\n  /**\r\n   * Returns the editor storage.\r\n   */\n  get storage() {\n    return this.extensionStorage;\n  }\n  /**\r\n   * An object of all registered commands.\r\n   */\n  get commands() {\n    return this.commandManager.commands;\n  }\n  /**\r\n   * Create a command chain to call multiple commands at once.\r\n   */\n  chain() {\n    return this.commandManager.chain();\n  }\n  /**\r\n   * Check if a command or a command chain can be executed. Without executing it.\r\n   */\n  can() {\n    return this.commandManager.can();\n  }\n  /**\r\n   * Inject CSS styles.\r\n   */\n  injectCSS() {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce);\n    }\n  }\n  /**\r\n   * Update editor options.\r\n   *\r\n   * @param options A list of options\r\n   */\n  setOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (!this.view || !this.state || this.isDestroyed) {\n      return;\n    }\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps);\n    }\n    this.view.updateState(this.state);\n  }\n  /**\r\n   * Update editable state of the editor.\r\n   */\n  setEditable(editable) {\n    let emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.setOptions({\n      editable\n    });\n    if (emitUpdate) {\n      this.emit('update', {\n        editor: this,\n        transaction: this.state.tr\n      });\n    }\n  }\n  /**\r\n   * Returns whether the editor is editable.\r\n   */\n  get isEditable() {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable;\n  }\n  /**\r\n   * Returns the editor state.\r\n   */\n  get state() {\n    return this.view.state;\n  }\n  /**\r\n   * Register a ProseMirror plugin.\r\n   *\r\n   * @param plugin A ProseMirror plugin\r\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n   */\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({\n      plugins\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Unregister a ProseMirror plugin.\r\n   *\r\n   * @param nameOrPluginKey The plugins name\r\n   */\n  unregisterPlugin(nameOrPluginKey) {\n    if (this.isDestroyed) {\n      return;\n    }\n    // @ts-ignore\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name))\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Creates an extension manager.\r\n   */\n  createExtensionManager() {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  /**\r\n   * Creates an command manager.\r\n   */\n  createCommandManager() {\n    this.commandManager = new CommandManager({\n      editor: this\n    });\n  }\n  /**\r\n   * Creates a ProseMirror schema.\r\n   */\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  /**\r\n   * Creates a ProseMirror view.\r\n   */\n  createView() {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\n    const selection = resolveFocusPosition(doc, this.options.autofocus);\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined\n      })\n    });\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.createNodeViews();\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  /**\r\n   * Creates all node views.\r\n   */\n  createNodeViews() {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  /**\r\n   * The callback over which to send transactions (state updates) produced by the view.\r\n   *\r\n   * @param transaction An editor state transaction\r\n   */\n  dispatchTransaction(transaction) {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return;\n    }\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n      transaction.steps.forEach(step => {\n        var _a;\n        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n      });\n      return;\n    }\n    const state = this.state.apply(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    this.view.updateState(state);\n    this.emit('transaction', {\n      editor: this,\n      transaction\n    });\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction\n      });\n    }\n    const focus = transaction.getMeta('focus');\n    const blur = transaction.getMeta('blur');\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction\n      });\n    }\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction\n      });\n    }\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return;\n    }\n    this.emit('update', {\n      editor: this,\n      transaction\n    });\n  }\n  /**\r\n   * Get attributes of the currently selected node or mark.\r\n   */\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  /**\r\n   * Get the document as JSON.\r\n   */\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  /**\r\n   * Get the document as HTML.\r\n   */\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc.content, this.schema);\n  }\n  /**\r\n   * Get the document as text.\r\n   */\n  getText(options) {\n    const {\n      blockSeparator = '\\n\\n',\n      textSerializers = {}\n    } = options || {};\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers\n      }\n    });\n  }\n  /**\r\n   * Check if there is no content.\r\n   */\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  /**\r\n   * Get the number of characters for the current document.\r\n   *\r\n   * @deprecated\r\n   */\n  getCharacterCount() {\n    console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n    return this.state.doc.content.size - 2;\n  }\n  /**\r\n   * Destroy the editor.\r\n   */\n  destroy() {\n    this.emit('destroy');\n    if (this.view) {\n      this.view.destroy();\n    }\n    this.removeAllListeners();\n  }\n  /**\r\n   * Check if the editor is already destroyed.\r\n   */\n  get isDestroyed() {\n    var _a;\n    // @ts-ignore\n    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n  }\n}\n\n/**\r\n * Build an input rule that adds a mark when the\r\n * matched text is typed into it.\r\n */\nfunction markInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref73 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref73;\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n/**\r\n * Build an input rule that adds a node when the\r\n * matched text is typed into it.\r\n */\nfunction nodeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref74 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref74;\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const {\n        tr\n      } = state;\n      const start = range.from;\n      let end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        let matchStart = start + offset;\n        if (matchStart > end) {\n          matchStart = end;\n        } else {\n          end = matchStart + match[1].length;\n        }\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1];\n        tr.insertText(lastChar, start + match[0].length - 1);\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, config.type.create(attributes));\n      } else if (match[0]) {\n        tr.replaceWith(start, end, config.type.create(attributes));\n      }\n    }\n  });\n}\n\n/**\r\n * Build an input rule that changes the type of a textblock when the\r\n * matched text is typed into it. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n */\nfunction textblockTypeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref75 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref75;\n      const $start = state.doc.resolve(range.from);\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null;\n      }\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n    }\n  });\n}\n\n/**\r\n * Build an input rule that replaces text when the\r\n * matched text is typed into it.\r\n */\nfunction textInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref76 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref76;\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n\n/**\r\n * Build an input rule for automatically wrapping a textblock when a\r\n * given string is typed. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n *\r\n * `type` is the type of node to wrap in.\r\n *\r\n * By default, if there’s a node with the same type above the newly\r\n * wrapped node, the rule will try to join those\r\n * two nodes. You can pass a join predicate, which takes a regular\r\n * expression match and the node before the wrapped node, and can\r\n * return a boolean to indicate whether a join should happen.\r\n */\nfunction wrappingInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref77 => {\n      let {\n        state,\n        range,\n        match,\n        chain\n      } = _ref77;\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const tr = state.tr.delete(range.from, range.to);\n      const $start = tr.doc.resolve(range.from);\n      const blockRange = $start.blockRange();\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);\n      if (!wrapping) {\n        return null;\n      }\n      tr.wrap(blockRange, wrapping);\n      if (config.keepMarks && config.editor) {\n        const {\n          selection,\n          storedMarks\n        } = state;\n        const {\n          splittableMarks\n        } = config.editor.extensionManager;\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n          tr.ensureMarks(filteredMarks);\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList';\n        chain().updateAttributes(nodeType, attributes).run();\n      }\n      const before = tr.doc.resolve(range.from - 1).nodeBefore;\n      if (before && before.type === config.type && canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n        tr.join(range.from - 1);\n      }\n    }\n  });\n}\nclass Mark {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'mark';\n    this.name = 'mark';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Mark(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Mark(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  static handleExit(_ref78) {\n    let {\n      editor,\n      mark\n    } = _ref78;\n    const {\n      tr\n    } = editor.state;\n    const currentPos = editor.state.selection.$from;\n    const isAtEnd = currentPos.pos === currentPos.end();\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks();\n      const isInMark = !!currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (!isInMark) {\n        return false;\n      }\n      const removeMark = currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (removeMark) {\n        tr.removeStoredMark(removeMark);\n      }\n      tr.insertText(' ', currentPos.pos);\n      editor.view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n}\nclass Node {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'node';\n    this.name = 'node';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Node(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Node(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nclass NodeView {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.component = component;\n    this.editor = props.editor;\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options\n    };\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n  mount() {\n    // eslint-disable-next-line\n    return;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  onDragStart(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const {\n      view\n    } = this.editor;\n    const target = event.target;\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]') : target.closest('[data-drag-handle]');\n    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect();\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n      x = handleBox.x - domBox.x + offsetX;\n      y = handleBox.y - domBox.y + offsetY;\n    }\n    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos());\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n  stopEvent(event) {\n    var _a;\n    if (!this.dom) {\n      return false;\n    }\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({\n        event\n      });\n    }\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false;\n    }\n    const isDragEvent = event.type.startsWith('drag');\n    const isDropEvent = event.type === 'drop';\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable;\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true;\n    }\n    const {\n      isEditable\n    } = this.editor;\n    const {\n      isDragging\n    } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === 'copy';\n    const isPasteEvent = event.type === 'paste';\n    const isCutEvent = event.type === 'cut';\n    const isClickEvent = event.type === 'mousedown';\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault();\n    }\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault();\n      return false;\n    }\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]');\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener('dragend', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('drop', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('mouseup', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n      }\n    }\n    // these events are handled by prosemirror\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n    return true;\n  }\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({\n        mutation\n      });\n    }\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true;\n    }\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false;\n    }\n    // try to prevent a bug on iOS that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    if (this.dom.contains(mutation.target) && mutation.type === 'childList' && isiOS() && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false;\n      }\n    }\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true;\n    }\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n  updateAttributes(attributes) {\n    this.editor.commands.command(_ref79 => {\n      let {\n        tr\n      } = _ref79;\n      const pos = this.getPos();\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes\n      });\n      return true;\n    });\n  }\n  deleteNode() {\n    const from = this.getPos();\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({\n      from,\n      to\n    });\n  }\n}\n\n/**\r\n * Build an paste rule that adds a mark when the\r\n * matched text is pasted into it.\r\n */\nfunction markPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: _ref80 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref80;\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n// source: https://stackoverflow.com/a/6969486\nfunction escapeForRegEx(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\r\n * Build an paste rule that adds a node when the\r\n * matched text is pasted into it.\r\n */\nfunction nodePasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler(_ref81) {\n      let {\n        match,\n        chain,\n        range\n      } = _ref81;\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes\n        });\n      }\n    }\n  });\n}\n\n/**\r\n * Build an paste rule that replaces text when the\r\n * matched text is pasted into it.\r\n */\nfunction textPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: _ref82 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref82;\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\nclass Tracker {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.currentStep = this.transaction.steps.length;\n  }\n  map(position) {\n    let deleted = false;\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition);\n      if (mapResult.deleted) {\n        deleted = true;\n      }\n      return mapResult.pos;\n    }, position);\n    return {\n      position: mappedPosition,\n      deleted\n    };\n  }\n}\nexport { CommandManager, Editor, Extension, InputRule, Mark, Node, NodeView, PasteRule, Tracker, callOrReturn, combineTransactionSteps, createChainableState, createDocument, createNodeFromContent, createStyleTag, defaultBlockAt, deleteProps, elementFromString, escapeForRegEx, extensions, findChildren, findChildrenInRange, findDuplicates, findParentNode, findParentNodeClosestToPos, fromString, generateHTML, generateJSON, generateText, getAttributes, getAttributesFromExtensions, getChangedRanges, getDebugJSON, getExtensionField, getHTMLFromFragment, getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, getNodeAttributes, getNodeType, getRenderedAttributes, getSchema, getSchemaByResolvedExtensions, getSchemaTypeByName, getSchemaTypeNameByName, getSplittedAttributes, getText, getTextBetween, getTextContentFromNodes, getTextSerializersFromSchema, injectExtensionAttributesToParseRule, inputRulesPlugin, isActive, isEmptyObject, isExtensionRulesEnabled, isFunction, isList, isMacOS, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isNumber, isPlainObject, isRegExp, isString, isTextSelection, isiOS, markInputRule, markPasteRule, mergeAttributes, mergeDeep, minMax, nodeInputRule, nodePasteRule, objectIncludes, pasteRulesPlugin, posToDOMRect, removeDuplicates, resolveFocusPosition, selectionToInsertionEnd, splitExtensions, textInputRule, textPasteRule, textblockTypeInputRule, wrappingInputRule };","map":{"version":3,"names":["createChainableState","config","state","transaction","selection","doc","storedMarks","apply","bind","applyTransaction","filterTransaction","plugins","schema","reconfigure","toJSON","tr","CommandManager","constructor","props","editor","rawCommands","extensionManager","commands","customState","hasCustomState","_this","view","buildProps","Object","fromEntries","entries","map","_ref","name","command","method","callback","arguments","getMeta","dispatch","chain","createChain","can","createCan","startTr","_this2","shouldDispatch","length","undefined","callbacks","hasStartTransaction","run","every","_ref2","chainedCommand","push","formattedCommands","_ref3","setStoredMarks","_ref4","EventEmitter","on","event","fn","emit","_len","args","Array","_key","forEach","off","filter","removeAllListeners","getExtensionField","extension","field","context","parent","value","splitExtensions","extensions","baseExtensions","type","nodeExtensions","markExtensions","getAttributesFromExtensions","extensionAttributes","nodeAndMarkExtensions","defaultAttribute","default","rendered","renderHTML","parseHTML","keepOnSplit","isRequired","options","storage","addGlobalAttributes","globalAttributes","globalAttribute","types","attributes","_ref5","attribute","addAttributes","_ref6","mergedAttr","getNodeType","nameOrType","nodes","Error","mergeAttributes","_len2","objects","_key2","item","reduce","items","mergedAttributes","_ref7","key","exists","join","getRenderedAttributes","nodeOrMark","attrs","isFunction","callOrReturn","_len3","_key3","isEmptyObject","keys","fromString","match","Number","injectExtensionAttributesToParseRule","parseRule","style","getAttrs","node","oldAttributes","newAttributes","getAttribute","cleanUpSchemaItem","data","_ref8","getSchemaByResolvedExtensions","allAttributes","topNode","_a","find","extraNodeFields","fields","e","extendNodeSchema","content","marks","group","inline","atom","selectable","draggable","code","defining","isolating","extensionAttribute","parseDOM","toDOM","HTMLAttributes","renderText","toText","extraMarkFields","extendMarkSchema","inclusive","excludes","spanning","mark","Schema","getSchemaTypeByName","isExtensionRulesEnabled","enabled","isArray","some","enabledExtension","getTextContentFromNodes","$from","maxMatch","textBefore","sliceEndPos","parentOffset","nodesBetween","Math","max","pos","index","chunk","_b","spec","call","textContent","slice","isRegExp","prototype","toString","InputRule","handler","inputRuleMatcherHandler","text","exec","inputRuleMatch","result","input","replaceWith","includes","console","warn","run$1","from","to","rules","plugin","composing","resolve","nodeBefore","nodeAfter","matched","rule","range","steps","setMeta","transform","inputRulesPlugin","Plugin","init","prev","stored","selectionSet","docChanged","handleTextInput","handleDOMEvents","compositionend","setTimeout","$cursor","handleKeyDown","isInputRules","isNumber","PasteRule","pasteRuleMatcherHandler","matchAll","matches","pasteRuleMatch","handlers","isTextblock","resolvedFrom","resolvedTo","min","size","textToMatch","textBetween","start","end","mapping","success","pasteRulesPlugin","dragSourceElement","isPastedFromProseMirror","isDroppedFromProseMirror","handleDragstart","dom","parentElement","contains","target","window","addEventListener","destroy","removeEventListener","drop","paste","html","clipboardData","getData","appendTransaction","transactions","oldState","isPaste","isDrop","findDiffStart","findDiffEnd","b","chainableState","findDuplicates","filtered","el","indexOf","Set","ExtensionManager","splittableMarks","extensionStorage","onBeforeCreate","onCreate","onUpdate","onSelectionUpdate","onTransaction","onFocus","onBlur","onDestroy","resolvedExtensions","sort","flatten","duplicatedNames","addExtensions","flat","defaultPriority","a","priorityA","priorityB","addCommands","reverse","inputRules","pasteRules","allPlugins","addKeyboardShortcuts","defaultBindings","exitable","ArrowRight","Mark","handleExit","bindings","_ref9","shortcut","keyMapPlugin","keymap","addInputRules","enableInputRules","addPasteRules","enablePasteRules","addProseMirrorPlugins","proseMirrorPlugins","nodeViews","addNodeView","nodeview","getPos","decorations","getType","isPlainObject","getPrototypeOf","mergeDeep","source","output","assign","Extension","child","defaultOptions","addOptions","create","configure","extend","extendedConfig","getTextBetween","startNode","blockSeparator","textSerializers","separated","textSerializer","isBlock","isText","getTextSerializersFromSchema","_ref10","_ref11","ClipboardTextSerializer","PluginKey","clipboardTextSerializer","ranges","$to","blur","_ref12","requestAnimationFrame","isDestroyed","getSelection","removeAllRanges","clearContent","emitUpdate","_ref13","setContent","clearNodes","_ref14","_ref15","$mappedFrom","$mappedTo","nodeSize","nodeRange","blockRange","targetLiftDepth","liftTarget","defaultType","contentMatchAt","setNodeMarkup","lift","createParagraphNear","_ref16","createParagraphNear$1","deleteCurrentNode","_ref17","currentNode","$anchor","$pos","depth","before","after","delete","scrollIntoView","deleteNode","typeOrName","_ref18","deleteRange","_ref19","deleteSelection","_ref20","deleteSelection$1","enter","_ref21","keyboardShortcut","exitCode","_ref22","exitCode$1","objectIncludes","object1","object2","strict","test","findMarkInSet","isMarkInSet","getMarkRange","childAfter","offset","childBefore","startIndex","startPos","endIndex","endPos","isInSet","childCount","getMarkType","extendMarkRange","_ref23","newSelection","TextSelection","setSelection","first","i","isTextSelection","minMax","resolveFocusPosition","position","selectionAtStart","Selection","atStart","selectionAtEnd","atEnd","minPos","maxPos","isiOS","navigator","platform","userAgent","document","focus","_ref24","delayedFocus","hasFocus","isSameSelection","eq","insertContent","_ref25","insertContentAt","elementFromString","wrappedValue","DOMParser","parseFromString","body","createNodeFromContent","parseOptions","Fragment","fromArray","nodeFromJSON","error","parser","fromSchema","parseSlice","parse","selectionToInsertionEnd","startLen","bias","last","step","ReplaceStep","ReplaceAroundStep","maps","_from","_to","_newFrom","newTo","near","isFragment","nodeOrFragment","startsWith","_ref26","updateSelection","preserveWhitespace","isOnlyTextContent","isOnlyBlockContent","check","isEmptyTextBlock","insertText","v","joinUp","_ref27","joinUp$1","joinDown","_ref28","joinDown$1","joinBackward","_ref29","joinBackward$1","joinForward","_ref30","joinForward$1","isMacOS","normalizeKeyName","parts","split","alt","ctrl","shift","meta","mod","_ref31","KeyboardEvent","altKey","ctrlKey","metaKey","shiftKey","bubbles","cancelable","capturedTransaction","captureTransaction","someProp","f","newStep","maybeStep","isNodeActive","empty","nodeRanges","relativeFrom","relativeTo","selectionRange","matchedNodeRanges","sum","_ref32","isActive","lift$1","liftEmptyBlock","_ref33","liftEmptyBlock$1","liftListItem","_ref34","liftListItem$1","newlineInCode","_ref35","newlineInCode$1","getSchemaTypeNameByName","deleteProps","obj","propOrProps","newObj","prop","resetAttributes","_ref36","nodeType","markType","schemaType","addMark","_ref37","selectAll","_ref38","setTextSelection","selectNodeBackward","_ref39","selectNodeBackward$1","selectNodeForward","_ref40","selectNodeForward$1","selectParentNode","_ref41","selectParentNode$1","selectTextblockEnd","_ref42","selectTextblockEnd$1","selectTextblockStart","_ref43","selectTextblockStart$1","createDocument","_ref44","combineTransactionSteps","oldDoc","Transform","defaultBlockAt","edgeCount","edge","hasRequiredAttrs","findChildren","predicate","nodesWithPos","descendants","findChildrenInRange","findParentNodeClosestToPos","findParentNode","getHTMLFromFragment","fragment","documentFragment","DOMSerializer","serializeFragment","temporaryDocument","implementation","createHTMLDocument","container","createElement","appendChild","innerHTML","getSchema","generateHTML","contentNode","Node$1","fromJSON","generateJSON","getText","generateText","getMarkAttributes","$head","markItem","getNodeAttributes","nodeItem","getAttributes","removeDuplicates","array","by","JSON","stringify","seen","hasOwnProperty","simplifyChangedRanges","changes","uniqueChanges","change","rest","_","otherChange","oldRange","newRange","getChangedRanges","stepMap","_ref45","newStart","newEnd","oldStart","invert","oldEnd","getDebugJSON","startOffset","isTopNode","topNodeType","increment","getMarksBetween","getSplittedAttributes","typeName","_ref46","isMarkActive","markRanges","_ref47","matchedRange","markRange","excludedRange","isList","isNodeEmpty","defaultContent","createAndFill","isNodeSelection","NodeSelection","posToDOMRect","resolvedEnd","coordsAtPos","top","bottom","left","right","width","height","x","y","canSetMark","newMarkType","cursor","currentMarks","_ref48","someNodeSupportsMark","inlineContent","allowsMarkType","_pos","isInline","parentAllowsMarkType","currentMarksAllowMarkType","otherMark","setMark","_ref49","addStoredMark","trimmedFrom","trimmedTo","someHasMark","_ref50","setNode","_ref51","_ref52","canSetBlock","setBlockType","_ref53","updatedState","setNodeSelection","_ref54","_ref55","sinkListItem","_ref56","sinkListItem$1","ensureMarks","filteredMarks","splitBlock","keepMarks","_ref57","canSplit","deflt","indexAfter","$first","canReplaceWith","splitListItem","_ref58","sameParent","grandParent","wrap","depthBefore","d","copy","depthAfter","newNextTypeAttributes","nextType","contentMatch","append","replace","Slice","sel","n","newTypeAttributes","joinListBackwards","listType","list","nodeAt","canJoinBackwards","canJoin","joinListForwards","canJoinForwards","toggleList","listTypeOrName","itemTypeOrName","_ref59","itemType","parentList","validContent","canWrapInList","wrapInList","toggleMark","_ref60","extendEmptyMarkRange","unsetMark","toggleNode","toggleTypeOrName","_ref61","toggleType","toggleWrap","_ref62","wrapIn","undoInputRule","_ref63","undoable","getState","toUndo","j","docs","unsetAllMarks","_ref64","removeMark","_ref65","removeStoredMark","updateAttributes","_ref66","_ref67","wrapIn$1","_ref68","wrapInList$1","Commands","Editable","editable","FocusEvents","isFocused","Keymap","handleBackspace","_ref69","_ref70","isAtStart","handleDelete","_ref71","handleEnter","_ref72","baseKeymap","Enter","Mod-Enter","Backspace","Delete","Mod-a","pcKeymap","macKeymap","Ctrl-a","Ctrl-e","newState","docChanges","allFrom","allEnd","allWasSelected","isEmpty","Tabindex","isEditable","tabindex","createStyleTag","nonce","tiptapStyleTag","querySelector","styleNode","setAttribute","getElementsByTagName","Editor","element","injectCSS","injectNonce","autofocus","editorProps","enableCoreExtensions","isCapturingTransaction","setOptions","createExtensionManager","createCommandManager","createSchema","createView","commandManager","css","setProps","updateState","setEditable","registerPlugin","handlePlugins","unregisterPlugin","nameOrPluginKey","coreExtensions","values","allExtensions","EditorView","dispatchTransaction","EditorState","createNodeViews","selectionHasChanged","nameOrAttributes","attributesOrUndefined","getJSON","getHTML","getCharacterCount","docView","markInputRule","_ref73","captureGroup","fullMatch","markEnd","startSpaces","search","textStart","textEnd","excludedMarks","excluded","nodeInputRule","_ref74","lastIndexOf","matchStart","lastChar","textblockTypeInputRule","_ref75","$start","textInputRule","_ref76","insert","cutOff","wrappingInputRule","_ref77","wrapping","findWrapping","keepAttributes","joinPredicate","_ref78","currentPos","isAtEnd","isInMark","m","Node","NodeView","component","isDragging","stopEvent","ignoreMutation","mount","contentDOM","onDragStart","dragHandle","closest","domBox","getBoundingClientRect","handleBox","offsetX","_c","_d","nativeEvent","offsetY","_e","_f","_g","dataTransfer","setDragImage","isInElement","isDragEvent","isDropEvent","isInput","tagName","isContentEditable","isDraggable","isSelectable","isCopyEvent","isPasteEvent","isCutEvent","isClickEvent","preventDefault","isValidDragHandle","once","mutation","isLeaf","isAtom","changedNodes","addedNodes","removedNodes","_ref79","markPasteRule","_ref80","escapeForRegEx","string","isString","nodePasteRule","_ref81","textPasteRule","_ref82","Tracker","currentStep","deleted","mappedPosition","newPosition","mapResult","getMap"],"sources":["C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\createChainableState.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\CommandManager.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\EventEmitter.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getExtensionField.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\splitExtensions.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getAttributesFromExtensions.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getNodeType.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\mergeAttributes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getRenderedAttributes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\isFunction.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\callOrReturn.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\isEmptyObject.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\fromString.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\injectExtensionAttributesToParseRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getSchemaByResolvedExtensions.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getSchemaTypeByName.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\isExtensionRulesEnabled.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getTextContentFromNodes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\isRegExp.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\InputRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\isNumber.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\PasteRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\findDuplicates.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\ExtensionManager.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\isPlainObject.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\mergeDeep.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\Extension.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getTextBetween.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getTextSerializersFromSchema.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\extensions\\clipboardTextSerializer.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\blur.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\clearContent.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\clearNodes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\command.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\createParagraphNear.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\deleteCurrentNode.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\deleteNode.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\deleteRange.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\deleteSelection.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\enter.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\exitCode.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\objectIncludes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getMarkRange.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getMarkType.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\extendMarkRange.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\first.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\isTextSelection.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\minMax.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\resolveFocusPosition.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\isiOS.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\focus.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\forEach.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\insertContent.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\elementFromString.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\createNodeFromContent.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\selectionToInsertionEnd.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\insertContentAt.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\join.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\isMacOS.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\keyboardShortcut.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\isNodeActive.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\lift.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\liftEmptyBlock.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\liftListItem.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\newlineInCode.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getSchemaTypeNameByName.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\deleteProps.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\resetAttributes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\scrollIntoView.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\selectAll.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\selectNodeBackward.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\selectNodeForward.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\selectParentNode.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\selectTextblockEnd.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\selectTextblockStart.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\createDocument.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\setContent.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\combineTransactionSteps.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\defaultBlockAt.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\findChildren.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\findChildrenInRange.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\findParentNodeClosestToPos.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\findParentNode.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getHTMLFromFragment.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getSchema.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\generateHTML.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\generateJSON.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getText.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\generateText.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getMarkAttributes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getNodeAttributes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getAttributes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\removeDuplicates.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getChangedRanges.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getDebugJSON.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getMarksBetween.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\getSplittedAttributes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\isMarkActive.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\isActive.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\isList.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\isNodeEmpty.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\isNodeSelection.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\helpers\\posToDOMRect.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\setMark.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\setMeta.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\setNode.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\setNodeSelection.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\setTextSelection.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\sinkListItem.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\splitBlock.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\splitListItem.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\toggleList.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\toggleMark.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\toggleNode.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\toggleWrap.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\undoInputRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\unsetAllMarks.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\unsetMark.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\updateAttributes.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\wrapIn.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\commands\\wrapInList.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\extensions\\commands.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\extensions\\editable.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\extensions\\focusEvents.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\extensions\\keymap.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\extensions\\tabindex.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\style.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\createStyleTag.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\Editor.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\inputRules\\markInputRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\inputRules\\nodeInputRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\inputRules\\textblockTypeInputRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\inputRules\\textInputRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\inputRules\\wrappingInputRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\Mark.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\Node.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\NodeView.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\pasteRules\\markPasteRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\escapeForRegEx.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\utilities\\isString.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\pasteRules\\nodePasteRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\pasteRules\\textPasteRule.ts","C:\\Users\\mohjam\\Desktop\\HIDiag-master\\node_modules\\@tiptap\\core\\src\\Tracker.ts"],"sourcesContent":["import { EditorState, Transaction } from '@tiptap/pm/state'\n\nexport function createChainableState(config: {\n  transaction: Transaction\n  state: EditorState\n}): EditorState {\n  const { state, transaction } = config\n  let { selection } = transaction\n  let { doc } = transaction\n  let { storedMarks } = transaction\n\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks\n    },\n    get selection() {\n      return selection\n    },\n    get doc() {\n      return doc\n    },\n    get tr() {\n      selection = transaction.selection\n      doc = transaction.doc\n      storedMarks = transaction.storedMarks\n\n      return transaction\n    },\n  }\n}\n","import { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor'\nimport { createChainableState } from './helpers/createChainableState'\nimport {\n  AnyCommands, CanCommands, ChainedCommands, CommandProps, SingleCommands,\n} from './types'\n\nexport class CommandManager {\n  editor: Editor\n\n  rawCommands: AnyCommands\n\n  customState?: EditorState\n\n  constructor(props: { editor: Editor; state?: EditorState }) {\n    this.editor = props.editor\n    this.rawCommands = this.editor.extensionManager.commands\n    this.customState = props.state\n  }\n\n  get hasCustomState(): boolean {\n    return !!this.customState\n  }\n\n  get state(): EditorState {\n    return this.customState || this.editor.state\n  }\n\n  get commands(): SingleCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const { tr } = state\n    const props = this.buildProps(tr)\n\n    return Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        const method = (...args: any[]) => {\n          const callback = command(...args)(props)\n\n          if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n            view.dispatch(tr)\n          }\n\n          return callback\n        }\n\n        return [name, method]\n      }),\n    ) as unknown as SingleCommands\n  }\n\n  get chain(): () => ChainedCommands {\n    return () => this.createChain()\n  }\n\n  get can(): () => CanCommands {\n    return () => this.createCan()\n  }\n\n  public createChain(startTr?: Transaction, shouldDispatch = true): ChainedCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const callbacks: boolean[] = []\n    const hasStartTransaction = !!startTr\n    const tr = startTr || state.tr\n\n    const run = () => {\n      if (\n        !hasStartTransaction\n        && shouldDispatch\n        && !tr.getMeta('preventDispatch')\n        && !this.hasCustomState\n      ) {\n        view.dispatch(tr)\n      }\n\n      return callbacks.every(callback => callback === true)\n    }\n\n    const chain = {\n      ...Object.fromEntries(\n        Object.entries(rawCommands).map(([name, command]) => {\n          const chainedCommand = (...args: never[]) => {\n            const props = this.buildProps(tr, shouldDispatch)\n            const callback = command(...args)(props)\n\n            callbacks.push(callback)\n\n            return chain\n          }\n\n          return [name, chainedCommand]\n        }),\n      ),\n      run,\n    } as unknown as ChainedCommands\n\n    return chain\n  }\n\n  public createCan(startTr?: Transaction): CanCommands {\n    const { rawCommands, state } = this\n    const dispatch = false\n    const tr = startTr || state.tr\n    const props = this.buildProps(tr, dispatch)\n    const formattedCommands = Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        return [name, (...args: never[]) => command(...args)({ ...props, dispatch: undefined })]\n      }),\n    ) as unknown as SingleCommands\n\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch),\n    } as CanCommands\n  }\n\n  public buildProps(tr: Transaction, shouldDispatch = true): CommandProps {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n\n    if (state.storedMarks) {\n      tr.setStoredMarks(state.storedMarks)\n    }\n\n    const props: CommandProps = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr,\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(\n          Object.entries(rawCommands).map(([name, command]) => {\n            return [name, (...args: never[]) => command(...args)(props)]\n          }),\n        ) as unknown as SingleCommands\n      },\n    }\n\n    return props\n  }\n}\n","type StringKeyOf<T> = Extract<keyof T, string>\ntype CallbackType<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = T[EventName] extends any[] ? T[EventName] : [T[EventName]]\ntype CallbackFunction<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = (...props: CallbackType<T, EventName>) => any\n\nexport class EventEmitter<T extends Record<string, any>> {\n\n  private callbacks: { [key: string]: Function[] } = {}\n\n  public on<EventName extends StringKeyOf<T>>(event: EventName, fn: CallbackFunction<T, EventName>): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = []\n    }\n\n    this.callbacks[event].push(fn)\n\n    return this\n  }\n\n  protected emit<EventName extends StringKeyOf<T>>(event: EventName, ...args: CallbackType<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args))\n    }\n\n    return this\n  }\n\n  public off<EventName extends StringKeyOf<T>>(event: EventName, fn?: CallbackFunction<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn)\n      } else {\n        delete this.callbacks[event]\n      }\n    }\n\n    return this\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {}\n  }\n}\n","import { AnyExtension, MaybeThisParameterType, RemoveThis } from '../types'\n\nexport function getExtensionField<T = any>(\n  extension: AnyExtension,\n  field: string,\n  context?: Omit<MaybeThisParameterType<T>, 'parent'>,\n): RemoveThis<T> {\n\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context)\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent\n        ? getExtensionField(extension.parent, field, context)\n        : null,\n    })\n\n    return value\n  }\n\n  return extension.config[field]\n}\n","import { Extension } from '../Extension'\nimport { Mark } from '../Mark'\nimport { Node } from '../Node'\nimport { Extensions } from '../types'\n\nexport function splitExtensions(extensions: Extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension') as Extension[]\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node') as Node[]\n  const markExtensions = extensions.filter(extension => extension.type === 'mark') as Mark[]\n\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions,\n  }\n}\n","import { MarkConfig, NodeConfig } from '..'\nimport {\n  AnyConfig,\n  Attribute,\n  Attributes,\n  ExtensionAttribute,\n  Extensions,\n  GlobalAttributes,\n} from '../types'\nimport { getExtensionField } from './getExtensionField'\nimport { splitExtensions } from './splitExtensions'\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nexport function getAttributesFromExtensions(extensions: Extensions): ExtensionAttribute[] {\n  const extensionAttributes: ExtensionAttribute[] = []\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions]\n  const defaultAttribute: Required<Attribute> = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false,\n  }\n\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addGlobalAttributes = getExtensionField<AnyConfig['addGlobalAttributes']>(\n      extension,\n      'addGlobalAttributes',\n      context,\n    )\n\n    if (!addGlobalAttributes) {\n      return\n    }\n\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes() as GlobalAttributes\n\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object\n          .entries(globalAttribute.attributes)\n          .forEach(([name, attribute]) => {\n            extensionAttributes.push({\n              type,\n              name,\n              attribute: {\n                ...defaultAttribute,\n                ...attribute,\n              },\n            })\n          })\n      })\n    })\n  })\n\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addAttributes = getExtensionField<NodeConfig['addAttributes'] | MarkConfig['addAttributes']>(\n      extension,\n      'addAttributes',\n      context,\n    )\n\n    if (!addAttributes) {\n      return\n    }\n\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes() as Attributes\n\n    Object\n      .entries(attributes)\n      .forEach(([name, attribute]) => {\n        const mergedAttr = {\n          ...defaultAttribute,\n          ...attribute,\n        }\n\n        if (typeof mergedAttr?.default === 'function') {\n          mergedAttr.default = mergedAttr.default()\n        }\n\n        if (mergedAttr?.isRequired && mergedAttr?.default === undefined) {\n          delete mergedAttr.default\n        }\n\n        extensionAttributes.push({\n          type: extension.name,\n          name,\n          attribute: mergedAttr,\n        })\n      })\n  })\n\n  return extensionAttributes\n}\n","import { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getNodeType(nameOrType: string | NodeType, schema: Schema): NodeType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(\n        `There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`,\n      )\n    }\n\n    return schema.nodes[nameOrType]\n  }\n\n  return nameOrType\n}\n","export function mergeAttributes(...objects: Record<string, any>[]): Record<string, any> {\n  return objects\n    .filter(item => !!item)\n    .reduce((items, item) => {\n      const mergedAttributes = { ...items }\n\n      Object.entries(item).forEach(([key, value]) => {\n        const exists = mergedAttributes[key]\n\n        if (!exists) {\n          mergedAttributes[key] = value\n\n          return\n        }\n\n        if (key === 'class') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join(' ')\n        } else if (key === 'style') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join('; ')\n        } else {\n          mergedAttributes[key] = value\n        }\n      })\n\n      return mergedAttributes\n    }, {})\n}\n","import { Mark, Node } from '@tiptap/pm/model'\n\nimport { ExtensionAttribute } from '../types'\nimport { mergeAttributes } from '../utilities/mergeAttributes'\n\nexport function getRenderedAttributes(\n  nodeOrMark: Node | Mark,\n  extensionAttributes: ExtensionAttribute[],\n): Record<string, any> {\n  return extensionAttributes\n    .filter(item => item.attribute.rendered)\n    .map(item => {\n      if (!item.attribute.renderHTML) {\n        return {\n          [item.name]: nodeOrMark.attrs[item.name],\n        }\n      }\n\n      return item.attribute.renderHTML(nodeOrMark.attrs) || {}\n    })\n    .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {})\n}\n","export function isFunction(value: any): value is Function {\n  return typeof value === 'function'\n}\n","import { MaybeReturnType } from '../types'\nimport { isFunction } from './isFunction'\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nexport function callOrReturn<T>(value: T, context: any = undefined, ...props: any[]): MaybeReturnType<T> {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props)\n    }\n\n    return value(...props)\n  }\n\n  return value as MaybeReturnType<T>\n}\n","export function isEmptyObject(value = {}): boolean {\n  return Object.keys(value).length === 0 && value.constructor === Object\n}\n","export function fromString(value: any): any {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value)\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n","import { ParseRule } from '@tiptap/pm/model'\n\nimport { ExtensionAttribute } from '../types'\nimport { fromString } from '../utilities/fromString'\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nexport function injectExtensionAttributesToParseRule(\n  parseRule: ParseRule,\n  extensionAttributes: ExtensionAttribute[],\n): ParseRule {\n  if (parseRule.style) {\n    return parseRule\n  }\n\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs\n\n      if (oldAttributes === false) {\n        return false\n      }\n\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML\n          ? item.attribute.parseHTML(node as HTMLElement)\n          : fromString((node as HTMLElement).getAttribute(item.name))\n\n        if (value === null || value === undefined) {\n          return items\n        }\n\n        return {\n          ...items,\n          [item.name]: value,\n        }\n      }, {})\n\n      return { ...oldAttributes, ...newAttributes }\n    },\n  }\n}\n","import { MarkSpec, NodeSpec, Schema } from '@tiptap/pm/model'\n\nimport { Editor, MarkConfig, NodeConfig } from '..'\nimport { AnyConfig, Extensions } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\nimport { isEmptyObject } from '../utilities/isEmptyObject'\nimport { getAttributesFromExtensions } from './getAttributesFromExtensions'\nimport { getExtensionField } from './getExtensionField'\nimport { getRenderedAttributes } from './getRenderedAttributes'\nimport { injectExtensionAttributesToParseRule } from './injectExtensionAttributesToParseRule'\nimport { splitExtensions } from './splitExtensions'\n\nfunction cleanUpSchemaItem<T>(data: T) {\n  return Object.fromEntries(\n    // @ts-ignore\n    Object.entries(data).filter(([key, value]) => {\n      if (key === 'attrs' && isEmptyObject(value as {} | undefined)) {\n        return false\n      }\n\n      return value !== null && value !== undefined\n    }),\n  ) as T\n}\n\nexport function getSchemaByResolvedExtensions(extensions: Extensions, editor?: Editor): Schema {\n  const allAttributes = getAttributesFromExtensions(extensions)\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const topNode = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))?.name\n\n  const nodes = Object.fromEntries(\n    nodeExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(\n        attribute => attribute.type === extension.name,\n      )\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n      }\n\n      const extraNodeFields = extensions.reduce((fields, e) => {\n        const extendNodeSchema = getExtensionField<AnyConfig['extendNodeSchema']>(\n          e,\n          'extendNodeSchema',\n          context,\n        )\n\n        return {\n          ...fields,\n          ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: NodeSpec = cleanUpSchemaItem({\n        ...extraNodeFields,\n        content: callOrReturn(\n          getExtensionField<NodeConfig['content']>(extension, 'content', context),\n        ),\n        marks: callOrReturn(getExtensionField<NodeConfig['marks']>(extension, 'marks', context)),\n        group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n        inline: callOrReturn(getExtensionField<NodeConfig['inline']>(extension, 'inline', context)),\n        atom: callOrReturn(getExtensionField<NodeConfig['atom']>(extension, 'atom', context)),\n        selectable: callOrReturn(\n          getExtensionField<NodeConfig['selectable']>(extension, 'selectable', context),\n        ),\n        draggable: callOrReturn(\n          getExtensionField<NodeConfig['draggable']>(extension, 'draggable', context),\n        ),\n        code: callOrReturn(getExtensionField<NodeConfig['code']>(extension, 'code', context)),\n        defining: callOrReturn(\n          getExtensionField<NodeConfig['defining']>(extension, 'defining', context),\n        ),\n        isolating: callOrReturn(\n          getExtensionField<NodeConfig['isolating']>(extension, 'isolating', context),\n        ),\n        attrs: Object.fromEntries(\n          extensionAttributes.map(extensionAttribute => {\n            return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n          }),\n        ),\n      })\n\n      const parseHTML = callOrReturn(\n        getExtensionField<NodeConfig['parseHTML']>(extension, 'parseHTML', context),\n      )\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n      }\n\n      const renderHTML = getExtensionField<NodeConfig['renderHTML']>(\n        extension,\n        'renderHTML',\n        context,\n      )\n\n      if (renderHTML) {\n        schema.toDOM = node => renderHTML({\n          node,\n          HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n        })\n      }\n\n      const renderText = getExtensionField<NodeConfig['renderText']>(\n        extension,\n        'renderText',\n        context,\n      )\n\n      if (renderText) {\n        schema.toText = renderText\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  const marks = Object.fromEntries(\n    markExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(\n        attribute => attribute.type === extension.name,\n      )\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n      }\n\n      const extraMarkFields = extensions.reduce((fields, e) => {\n        const extendMarkSchema = getExtensionField<AnyConfig['extendMarkSchema']>(\n          e,\n          'extendMarkSchema',\n          context,\n        )\n\n        return {\n          ...fields,\n          ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: MarkSpec = cleanUpSchemaItem({\n        ...extraMarkFields,\n        inclusive: callOrReturn(\n          getExtensionField<MarkConfig['inclusive']>(extension, 'inclusive', context),\n        ),\n        excludes: callOrReturn(\n          getExtensionField<MarkConfig['excludes']>(extension, 'excludes', context),\n        ),\n        group: callOrReturn(getExtensionField<MarkConfig['group']>(extension, 'group', context)),\n        spanning: callOrReturn(\n          getExtensionField<MarkConfig['spanning']>(extension, 'spanning', context),\n        ),\n        code: callOrReturn(getExtensionField<MarkConfig['code']>(extension, 'code', context)),\n        attrs: Object.fromEntries(\n          extensionAttributes.map(extensionAttribute => {\n            return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n          }),\n        ),\n      })\n\n      const parseHTML = callOrReturn(\n        getExtensionField<MarkConfig['parseHTML']>(extension, 'parseHTML', context),\n      )\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n      }\n\n      const renderHTML = getExtensionField<MarkConfig['renderHTML']>(\n        extension,\n        'renderHTML',\n        context,\n      )\n\n      if (renderHTML) {\n        schema.toDOM = mark => renderHTML({\n          mark,\n          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n        })\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  return new Schema({\n    topNode,\n    nodes,\n    marks,\n  })\n}\n","import { MarkType, NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getSchemaTypeByName(name: string, schema: Schema): NodeType | MarkType | null {\n  return schema.nodes[name] || schema.marks[name] || null\n}\n","import { AnyExtension, EnableRules } from '../types'\n\nexport function isExtensionRulesEnabled(extension: AnyExtension, enabled: EnableRules): boolean {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string'\n        ? enabledExtension\n        : enabledExtension.name\n\n      return name === extension.name\n    })\n  }\n\n  return enabled\n}\n","import { ResolvedPos } from '@tiptap/pm/model'\n\nexport const getTextContentFromNodes = ($from: ResolvedPos, maxMatch = 500) => {\n  let textBefore = ''\n\n  const sliceEndPos = $from.parentOffset\n\n  $from.parent.nodesBetween(\n    Math.max(0, sliceEndPos - maxMatch),\n    sliceEndPos,\n    (node, pos, parent, index) => {\n      const chunk = node.type.spec.toText?.({\n        node,\n        pos,\n        parent,\n        index,\n      })\n        || node.textContent\n        || '%leaf%'\n\n      textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos))\n    },\n  )\n\n  return textBefore\n}\n","export function isRegExp(value: any): value is RegExp {\n  return Object.prototype.toString.call(value) === '[object RegExp]'\n}\n","import { EditorState, Plugin, TextSelection } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager'\nimport { Editor } from './Editor'\nimport { createChainableState } from './helpers/createChainableState'\nimport { getTextContentFromNodes } from './helpers/getTextContentFromNodes'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types'\nimport { isRegExp } from './utilities/isRegExp'\n\nexport type InputRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type InputRuleFinder = RegExp | ((text: string) => InputRuleMatch | null)\n\nexport class InputRule {\n  find: InputRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n  }) => void | null\n\n  constructor(config: {\n    find: InputRuleFinder\n    handler: (props: {\n      state: EditorState\n      range: Range\n      match: ExtendedRegExpMatchArray\n      commands: SingleCommands\n      chain: () => ChainedCommands\n      can: () => CanCommands\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst inputRuleMatcherHandler = (\n  text: string,\n  find: InputRuleFinder,\n): ExtendedRegExpMatchArray | null => {\n  if (isRegExp(find)) {\n    return find.exec(text)\n  }\n\n  const inputRuleMatch = find(text)\n\n  if (!inputRuleMatch) {\n    return null\n  }\n\n  const result: ExtendedRegExpMatchArray = [inputRuleMatch.text]\n\n  result.index = inputRuleMatch.index\n  result.input = text\n  result.data = inputRuleMatch.data\n\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn(\n        '[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".',\n      )\n    }\n\n    result.push(inputRuleMatch.replaceWith)\n  }\n\n  return result\n}\n\nfunction run(config: {\n  editor: Editor\n  from: number\n  to: number\n  text: string\n  rules: InputRule[]\n  plugin: Plugin\n}): boolean {\n  const {\n    editor, from, to, text, rules, plugin,\n  } = config\n  const { view } = editor\n\n  if (view.composing) {\n    return false\n  }\n\n  const $from = view.state.doc.resolve(from)\n\n  if (\n    // check for code node\n    $from.parent.type.spec.code\n    // check for code mark\n    || !!($from.nodeBefore || $from.nodeAfter)?.marks.find(mark => mark.type.spec.code)\n  ) {\n    return false\n  }\n\n  let matched = false\n\n  const textBefore = getTextContentFromNodes($from) + text\n\n  rules.forEach(rule => {\n    if (matched) {\n      return\n    }\n\n    const match = inputRuleMatcherHandler(textBefore, rule.find)\n\n    if (!match) {\n      return\n    }\n\n    const tr = view.state.tr\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr,\n    })\n    const range = {\n      from: from - (match[0].length - text.length),\n      to,\n    }\n\n    const { commands, chain, can } = new CommandManager({\n      editor,\n      state,\n    })\n\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can,\n    })\n\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return\n    }\n\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text,\n    })\n\n    view.dispatch(tr)\n    matched = true\n  })\n\n  return matched\n}\n\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function inputRulesPlugin(props: { editor: Editor; rules: InputRule[] }): Plugin {\n  const { editor, rules } = props\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin)\n\n        if (stored) {\n          return stored\n        }\n\n        return tr.selectionSet || tr.docChanged ? null : prev\n      },\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin,\n        })\n      },\n\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection as TextSelection\n\n            if ($cursor) {\n              run({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin,\n              })\n            }\n          })\n\n          return false\n        },\n      },\n\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false\n        }\n\n        const { $cursor } = view.state.selection as TextSelection\n\n        if ($cursor) {\n          return run({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin,\n          })\n        }\n\n        return false\n      },\n    },\n\n    // @ts-ignore\n    isInputRules: true,\n  }) as Plugin\n\n  return plugin\n}\n","export function isNumber(value: any): value is number {\n  return typeof value === 'number'\n}\n","import { EditorState, Plugin } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager'\nimport { Editor } from './Editor'\nimport { createChainableState } from './helpers/createChainableState'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types'\nimport { isNumber } from './utilities/isNumber'\nimport { isRegExp } from './utilities/isRegExp'\n\nexport type PasteRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type PasteRuleFinder = RegExp | ((text: string) => PasteRuleMatch[] | null | undefined)\n\nexport class PasteRule {\n  find: PasteRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n  }) => void | null\n\n  constructor(config: {\n    find: PasteRuleFinder\n    handler: (props: {\n      state: EditorState\n      range: Range\n      match: ExtendedRegExpMatchArray\n      commands: SingleCommands\n      chain: () => ChainedCommands\n      can: () => CanCommands\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst pasteRuleMatcherHandler = (\n  text: string,\n  find: PasteRuleFinder,\n): ExtendedRegExpMatchArray[] => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)]\n  }\n\n  const matches = find(text)\n\n  if (!matches) {\n    return []\n  }\n\n  return matches.map(pasteRuleMatch => {\n    const result: ExtendedRegExpMatchArray = [pasteRuleMatch.text]\n\n    result.index = pasteRuleMatch.index\n    result.input = text\n    result.data = pasteRuleMatch.data\n\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn(\n          '[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".',\n        )\n      }\n\n      result.push(pasteRuleMatch.replaceWith)\n    }\n\n    return result\n  })\n}\n\nfunction run(config: {\n  editor: Editor\n  state: EditorState\n  from: number\n  to: number\n  rule: PasteRule\n}): boolean {\n  const {\n    editor, state, from, to, rule,\n  } = config\n\n  const { commands, chain, can } = new CommandManager({\n    editor,\n    state,\n  })\n\n  const handlers: (void | null)[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return\n    }\n\n    const resolvedFrom = Math.max(from, pos)\n    const resolvedTo = Math.min(to, pos + node.content.size)\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc')\n\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find)\n\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return\n      }\n\n      const start = resolvedFrom + match.index + 1\n      const end = start + match[0].length\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end),\n      }\n\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n      })\n\n      handlers.push(handler)\n    })\n  })\n\n  const success = handlers.every(handler => handler !== null)\n\n  return success\n}\n\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function pasteRulesPlugin(props: { editor: Editor; rules: PasteRule[] }): Plugin[] {\n  const { editor, rules } = props\n  let dragSourceElement: Element | null = null\n  let isPastedFromProseMirror = false\n  let isDroppedFromProseMirror = false\n\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = (event: DragEvent) => {\n          dragSourceElement = view.dom.parentElement?.contains(event.target as Element)\n            ? view.dom.parentElement\n            : null\n        }\n\n        window.addEventListener('dragstart', handleDragstart)\n\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart)\n          },\n        }\n      },\n\n      props: {\n        handleDOMEvents: {\n          drop: view => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement\n\n            return false\n          },\n\n          paste: (view, event: Event) => {\n            const html = (event as ClipboardEvent).clipboardData?.getData('text/html')\n\n            isPastedFromProseMirror = !!html?.includes('data-pm-slice')\n\n            return false\n          },\n        },\n      },\n\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0]\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror\n\n        if (!isPaste && !isDrop) {\n          return\n        }\n\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content)\n        const to = oldState.doc.content.findDiffEnd(state.doc.content)\n\n        if (!isNumber(from) || !to || from === to.b) {\n          return\n        }\n\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr\n        const chainableState = createChainableState({\n          state,\n          transaction: tr,\n        })\n\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule,\n        })\n\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return\n        }\n\n        return tr\n      },\n    })\n  })\n\n  return plugins\n}\n","export function findDuplicates(items: any[]): any[] {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index)\n\n  return [...new Set(filtered)]\n}\n","import { keymap } from '@tiptap/pm/keymap'\nimport { Node as ProsemirrorNode, Schema } from '@tiptap/pm/model'\nimport { Plugin } from '@tiptap/pm/state'\nimport { Decoration, EditorView } from '@tiptap/pm/view'\n\nimport { Mark, NodeConfig } from '.'\nimport { Editor } from './Editor'\nimport { getAttributesFromExtensions } from './helpers/getAttributesFromExtensions'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { getNodeType } from './helpers/getNodeType'\nimport { getRenderedAttributes } from './helpers/getRenderedAttributes'\nimport { getSchemaByResolvedExtensions } from './helpers/getSchemaByResolvedExtensions'\nimport { getSchemaTypeByName } from './helpers/getSchemaTypeByName'\nimport { isExtensionRulesEnabled } from './helpers/isExtensionRulesEnabled'\nimport { splitExtensions } from './helpers/splitExtensions'\nimport { inputRulesPlugin } from './InputRule'\nimport { pasteRulesPlugin } from './PasteRule'\nimport { AnyConfig, Extensions, RawCommands } from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { findDuplicates } from './utilities/findDuplicates'\n\nexport class ExtensionManager {\n  editor: Editor\n\n  schema: Schema\n\n  extensions: Extensions\n\n  splittableMarks: string[] = []\n\n  constructor(extensions: Extensions, editor: Editor) {\n    this.editor = editor\n    this.extensions = ExtensionManager.resolve(extensions)\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor)\n\n    this.extensions.forEach(extension => {\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage\n\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = callOrReturn(getExtensionField(extension, 'keepOnSplit', context)) ?? true\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name)\n        }\n      }\n\n      const onBeforeCreate = getExtensionField<AnyConfig['onBeforeCreate']>(\n        extension,\n        'onBeforeCreate',\n        context,\n      )\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate)\n      }\n\n      const onCreate = getExtensionField<AnyConfig['onCreate']>(extension, 'onCreate', context)\n\n      if (onCreate) {\n        this.editor.on('create', onCreate)\n      }\n\n      const onUpdate = getExtensionField<AnyConfig['onUpdate']>(extension, 'onUpdate', context)\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate)\n      }\n\n      const onSelectionUpdate = getExtensionField<AnyConfig['onSelectionUpdate']>(\n        extension,\n        'onSelectionUpdate',\n        context,\n      )\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate)\n      }\n\n      const onTransaction = getExtensionField<AnyConfig['onTransaction']>(\n        extension,\n        'onTransaction',\n        context,\n      )\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction)\n      }\n\n      const onFocus = getExtensionField<AnyConfig['onFocus']>(extension, 'onFocus', context)\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus)\n      }\n\n      const onBlur = getExtensionField<AnyConfig['onBlur']>(extension, 'onBlur', context)\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur)\n      }\n\n      const onDestroy = getExtensionField<AnyConfig['onDestroy']>(extension, 'onDestroy', context)\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy)\n      }\n    })\n  }\n\n  static resolve(extensions: Extensions): Extensions {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions))\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name))\n\n    if (duplicatedNames.length) {\n      console.warn(\n        `[tiptap warn]: Duplicate extension names found: [${duplicatedNames\n          .map(item => `'${item}'`)\n          .join(', ')}]. This can lead to issues.`,\n      )\n    }\n\n    return resolvedExtensions\n  }\n\n  static flatten(extensions: Extensions): Extensions {\n    return (\n      extensions\n        .map(extension => {\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n          }\n\n          const addExtensions = getExtensionField<AnyConfig['addExtensions']>(\n            extension,\n            'addExtensions',\n            context,\n          )\n\n          if (addExtensions) {\n            return [extension, ...this.flatten(addExtensions())]\n          }\n\n          return extension\n        })\n        // `Infinity` will break TypeScript so we set a number that is probably high enough\n        .flat(10)\n    )\n  }\n\n  static sort(extensions: Extensions): Extensions {\n    const defaultPriority = 100\n\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField<AnyConfig['priority']>(a, 'priority') || defaultPriority\n      const priorityB = getExtensionField<AnyConfig['priority']>(b, 'priority') || defaultPriority\n\n      if (priorityA > priorityB) {\n        return -1\n      }\n\n      if (priorityA < priorityB) {\n        return 1\n      }\n\n      return 0\n    })\n  }\n\n  get commands(): RawCommands {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const addCommands = getExtensionField<AnyConfig['addCommands']>(\n        extension,\n        'addCommands',\n        context,\n      )\n\n      if (!addCommands) {\n        return commands\n      }\n\n      return {\n        ...commands,\n        ...addCommands(),\n      }\n    }, {} as RawCommands)\n  }\n\n  get plugins(): Plugin[] {\n    const { editor } = this\n\n    // With ProseMirror, first plugins within an array are executed first.\n    // In Tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse())\n\n    const inputRules: any[] = []\n    const pasteRules: any[] = []\n\n    const allPlugins = extensions\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: extension.storage,\n          editor,\n          type: getSchemaTypeByName(extension.name, this.schema),\n        }\n\n        const plugins: Plugin[] = []\n\n        const addKeyboardShortcuts = getExtensionField<AnyConfig['addKeyboardShortcuts']>(\n          extension,\n          'addKeyboardShortcuts',\n          context,\n        )\n\n        let defaultBindings: Record<string, () => boolean> = {}\n\n        // bind exit handling\n        if (extension.type === 'mark' && extension.config.exitable) {\n          defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension as Mark })\n        }\n\n        if (addKeyboardShortcuts) {\n          const bindings = Object.fromEntries(\n            Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n              return [shortcut, () => method({ editor })]\n            }),\n          )\n\n          defaultBindings = { ...defaultBindings, ...bindings }\n        }\n\n        const keyMapPlugin = keymap(defaultBindings)\n\n        plugins.push(keyMapPlugin)\n\n        const addInputRules = getExtensionField<AnyConfig['addInputRules']>(\n          extension,\n          'addInputRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n          inputRules.push(...addInputRules())\n        }\n\n        const addPasteRules = getExtensionField<AnyConfig['addPasteRules']>(\n          extension,\n          'addPasteRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n          pasteRules.push(...addPasteRules())\n        }\n\n        const addProseMirrorPlugins = getExtensionField<AnyConfig['addProseMirrorPlugins']>(\n          extension,\n          'addProseMirrorPlugins',\n          context,\n        )\n\n        if (addProseMirrorPlugins) {\n          const proseMirrorPlugins = addProseMirrorPlugins()\n\n          plugins.push(...proseMirrorPlugins)\n        }\n\n        return plugins\n      })\n      .flat()\n\n    return [\n      inputRulesPlugin({\n        editor,\n        rules: inputRules,\n      }),\n      ...pasteRulesPlugin({\n        editor,\n        rules: pasteRules,\n      }),\n      ...allPlugins,\n    ]\n  }\n\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions)\n  }\n\n  get nodeViews() {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(\n      nodeExtensions\n        .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n        .map(extension => {\n          const extensionAttributes = this.attributes.filter(\n            attribute => attribute.type === extension.name,\n          )\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor,\n            type: getNodeType(extension.name, this.schema),\n          }\n          const addNodeView = getExtensionField<NodeConfig['addNodeView']>(\n            extension,\n            'addNodeView',\n            context,\n          )\n\n          if (!addNodeView) {\n            return []\n          }\n\n          const nodeview = (\n            node: ProsemirrorNode,\n            view: EditorView,\n            getPos: (() => number) | boolean,\n            decorations: Decoration[],\n          ) => {\n            const HTMLAttributes = getRenderedAttributes(node, extensionAttributes)\n\n            return addNodeView()({\n              editor,\n              node,\n              getPos,\n              decorations,\n              HTMLAttributes,\n              extension,\n            })\n          }\n\n          return [extension.name, nodeview]\n        }),\n    )\n  }\n}\n","// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\nfunction getType(value: any): string {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nexport function isPlainObject(value: any): value is Record<string, any> {\n  if (getType(value) !== 'Object') {\n    return false\n  }\n\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype\n}\n","import { isPlainObject } from './isPlainObject'\n\nexport function mergeDeep(target: Record<string, any>, source: Record<string, any>): Record<string, any> {\n  const output = { ...target }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] })\n        } else {\n          output[key] = mergeDeep(target[key], source[key])\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] })\n      }\n    })\n  }\n\n  return output\n}\n","import { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { ExtensionConfig } from '.'\nimport { Editor } from './Editor'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { InputRule } from './InputRule'\nimport { Mark } from './Mark'\nimport { Node } from './Node'\nimport { PasteRule } from './PasteRule'\nimport {\n  AnyConfig,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { mergeDeep } from './utilities/mergeDeep'\n\ndeclare module '@tiptap/core' {\n  interface ExtensionConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Mark,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n  }\n}\n\nexport class Extension<Options = any, Storage = any> {\n  type = 'extension'\n\n  name = 'extension'\n\n  parent: Extension | null = null\n\n  child: Extension | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: ExtensionConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<ExtensionConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<ExtensionConfig<O, S>> = {}) {\n    return new Extension<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<ExtensionConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Extension<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { Range, TextSerializer } from '../types'\n\nexport function getTextBetween(\n  startNode: ProseMirrorNode,\n  range: Range,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { from, to } = range\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  let text = ''\n  let separated = true\n\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    const textSerializer = textSerializers?.[node.type.name]\n\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator\n        separated = true\n      }\n\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range,\n        })\n      }\n    } else if (node.isText) {\n      text += node?.text?.slice(Math.max(from, pos) - pos, to - pos) // eslint-disable-line\n      separated = false\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator\n      separated = true\n    }\n  })\n\n  return text\n}\n","import { Schema } from '@tiptap/pm/model'\n\nimport { TextSerializer } from '../types'\n\nexport function getTextSerializersFromSchema(schema: Schema): Record<string, TextSerializer> {\n  return Object.fromEntries(\n    Object.entries(schema.nodes)\n      .filter(([, node]) => node.spec.toText)\n      .map(([name, node]) => [name, node.spec.toText]),\n  )\n}\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension'\nimport { getTextBetween } from '../helpers/getTextBetween'\nimport { getTextSerializersFromSchema } from '../helpers/getTextSerializersFromSchema'\n\nexport const ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('clipboardTextSerializer'),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this\n            const { state, schema } = editor\n            const { doc, selection } = state\n            const { ranges } = selection\n            const from = Math.min(...ranges.map(range => range.$from.pos))\n            const to = Math.max(...ranges.map(range => range.$to.pos))\n            const textSerializers = getTextSerializersFromSchema(schema)\n            const range = { from, to }\n\n            return getTextBetween(doc, range, {\n              textSerializers,\n            })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blur: {\n      /**\n       * Removes focus from the editor.\n       */\n      blur: () => ReturnType,\n    }\n  }\n}\n\nexport const blur: RawCommands['blur'] = () => ({ editor, view }) => {\n  requestAnimationFrame(() => {\n    if (!editor.isDestroyed) {\n      (view.dom as HTMLElement).blur()\n\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      window?.getSelection()?.removeAllRanges()\n    }\n  })\n\n  return true\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearContent: {\n      /**\n       * Clear the whole document.\n       */\n      clearContent: (emitUpdate?: boolean) => ReturnType,\n    }\n  }\n}\n\nexport const clearContent: RawCommands['clearContent'] = (emitUpdate = false) => ({ commands }) => {\n  return commands.setContent('', emitUpdate)\n}\n","import { liftTarget } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearNodes: {\n      /**\n       * Normalize nodes to a simple paragraph.\n       */\n      clearNodes: () => ReturnType,\n    }\n  }\n}\n\nexport const clearNodes: RawCommands['clearNodes'] = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr\n  const { ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return\n      }\n\n      const { doc, mapping } = tr\n      const $mappedFrom = doc.resolve(mapping.map(pos))\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize))\n      const nodeRange = $mappedFrom.blockRange($mappedTo)\n\n      if (!nodeRange) {\n        return\n      }\n\n      const targetLiftDepth = liftTarget(nodeRange)\n\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index())\n\n        tr.setNodeMarkup(nodeRange.start, defaultType)\n      }\n\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth)\n      }\n    })\n  })\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    command: {\n      /**\n       * Define a command inline.\n       */\n      command: (fn: (props: Parameters<Command>[0]) => boolean) => ReturnType,\n    }\n  }\n}\n\nexport const command: RawCommands['command'] = fn => props => {\n  return fn(props)\n}\n","import { createParagraphNear as originalCreateParagraphNear } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    createParagraphNear: {\n      /**\n       * Create a paragraph nearby.\n       */\n      createParagraphNear: () => ReturnType\n    }\n  }\n}\n\nexport const createParagraphNear: RawCommands['createParagraphNear'] = () => ({ state, dispatch }) => {\n  return originalCreateParagraphNear(state, dispatch)\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteCurrentNode: {\n      /**\n       * Delete the node that currently has the selection anchor.\n       */\n      deleteCurrentNode: () => ReturnType,\n    }\n  }\n}\n\nexport const deleteCurrentNode: RawCommands['deleteCurrentNode'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const currentNode = selection.$anchor.node()\n\n  // if there is content inside the current node, break out of this command\n  if (currentNode.content.size > 0) {\n    return false\n  }\n\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteNode: {\n      /**\n       * Delete a node.\n       */\n      deleteNode: (typeOrName: string | NodeType) => ReturnType,\n    }\n  }\n}\n\nexport const deleteNode: RawCommands['deleteNode'] = typeOrName => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { Range, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteRange: {\n      /**\n       * Delete a given range.\n       */\n      deleteRange: (range: Range) => ReturnType,\n    }\n  }\n}\n\nexport const deleteRange: RawCommands['deleteRange'] = range => ({ tr, dispatch }) => {\n  const { from, to } = range\n\n  if (dispatch) {\n    tr.delete(from, to)\n  }\n\n  return true\n}\n","import { deleteSelection as originalDeleteSelection } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteSelection: {\n      /**\n       * Delete the selection, if there is one.\n       */\n      deleteSelection: () => ReturnType\n    }\n  }\n}\n\nexport const deleteSelection: RawCommands['deleteSelection'] = () => ({ state, dispatch }) => {\n  return originalDeleteSelection(state, dispatch)\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    enter: {\n      /**\n       * Trigger enter.\n       */\n      enter: () => ReturnType,\n    }\n  }\n}\n\nexport const enter: RawCommands['enter'] = () => ({ commands }) => {\n  return commands.keyboardShortcut('Enter')\n}\n","import { exitCode as originalExitCode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    exitCode: {\n      /**\n       * Exit from a code block.\n       */\n      exitCode: () => ReturnType\n    }\n  }\n}\n\nexport const exitCode: RawCommands['exitCode'] = () => ({ state, dispatch }) => {\n  return originalExitCode(state, dispatch)\n}\n","import { isRegExp } from './isRegExp'\n\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nexport function objectIncludes(\n  object1: Record<string, any>,\n  object2: Record<string, any>,\n  options: { strict: boolean } = { strict: true },\n): boolean {\n  const keys = Object.keys(object2)\n\n  if (!keys.length) {\n    return true\n  }\n\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key]\n    }\n\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key])\n    }\n\n    return object2[key] === object1[key]\n  })\n}\n","import { Mark as ProseMirrorMark, MarkType, ResolvedPos } from '@tiptap/pm/model'\n\nimport { Range } from '../types'\nimport { objectIncludes } from '../utilities/objectIncludes'\n\nfunction findMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): ProseMirrorMark | undefined {\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes)\n  })\n}\n\nfunction isMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): boolean {\n  return !!findMarkInSet(marks, type, attributes)\n}\n\nexport function getMarkRange(\n  $pos: ResolvedPos,\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): Range | void {\n  if (!$pos || !type) {\n    return\n  }\n\n  let start = $pos.parent.childAfter($pos.parentOffset)\n\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset)\n  }\n\n  if (!start.node) {\n    return\n  }\n\n  const mark = findMarkInSet([...start.node.marks], type, attributes)\n\n  if (!mark) {\n    return\n  }\n\n  let startIndex = start.index\n  let startPos = $pos.start() + start.offset\n  let endIndex = startIndex + 1\n  let endPos = startPos + start.node.nodeSize\n\n  findMarkInSet([...start.node.marks], type, attributes)\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1\n    startPos -= $pos.parent.child(startIndex).nodeSize\n  }\n\n  while (\n    endIndex < $pos.parent.childCount\n    && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)\n  ) {\n    endPos += $pos.parent.child(endIndex).nodeSize\n    endIndex += 1\n  }\n\n  return {\n    from: startPos,\n    to: endPos,\n  }\n}\n","import { MarkType, Schema } from '@tiptap/pm/model'\n\nexport function getMarkType(nameOrType: string | MarkType, schema: Schema): MarkType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(\n        `There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`,\n      )\n    }\n\n    return schema.marks[nameOrType]\n  }\n\n  return nameOrType\n}\n","import { MarkType } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\n\nimport { getMarkRange } from '../helpers/getMarkRange'\nimport { getMarkType } from '../helpers/getMarkType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    extendMarkRange: {\n      /**\n       * Extends the text selection to the current mark.\n       */\n      extendMarkRange: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const extendMarkRange: RawCommands['extendMarkRange'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema)\n  const { doc, selection } = tr\n  const { $from, from, to } = selection\n\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes)\n\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = TextSelection.create(doc, range.from, range.to)\n\n      tr.setSelection(newSelection)\n    }\n  }\n\n  return true\n}\n","import { Command, CommandProps, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    first: {\n      /**\n       * Runs one command after the other and stops at the first which returns true.\n       */\n      first: (commands: Command[] | ((props: CommandProps) => Command[])) => ReturnType,\n    }\n  }\n}\n\nexport const first: RawCommands['first'] = commands => props => {\n  const items = typeof commands === 'function'\n    ? commands(props)\n    : commands\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true\n    }\n  }\n\n  return false\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nexport function isTextSelection(value: unknown): value is TextSelection {\n  return value instanceof TextSelection\n}\n","export function minMax(value = 0, min = 0, max = 0): number {\n  return Math.min(Math.max(value, min), max)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Selection, TextSelection } from '@tiptap/pm/state'\n\nimport { FocusPosition } from '../types'\nimport { minMax } from '../utilities/minMax'\n\nexport function resolveFocusPosition(\n  doc: ProseMirrorNode,\n  position: FocusPosition = null,\n): Selection | null {\n  if (!position) {\n    return null\n  }\n\n  const selectionAtStart = Selection.atStart(doc)\n  const selectionAtEnd = Selection.atEnd(doc)\n\n  if (position === 'start' || position === true) {\n    return selectionAtStart\n  }\n\n  if (position === 'end') {\n    return selectionAtEnd\n  }\n\n  const minPos = selectionAtStart.from\n  const maxPos = selectionAtEnd.to\n\n  if (position === 'all') {\n    return TextSelection.create(\n      doc,\n      minMax(0, minPos, maxPos),\n      minMax(doc.content.size, minPos, maxPos),\n    )\n  }\n\n  return TextSelection.create(\n    doc,\n    minMax(position, minPos, maxPos),\n    minMax(position, minPos, maxPos),\n  )\n}\n","export function isiOS(): boolean {\n  return [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod',\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes('Mac') && 'ontouchend' in document)\n}\n","import { isTextSelection } from '../helpers/isTextSelection'\nimport { resolveFocusPosition } from '../helpers/resolveFocusPosition'\nimport { FocusPosition, RawCommands } from '../types'\nimport { isiOS } from '../utilities/isiOS'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    focus: {\n      /**\n       * Focus the editor at the given position.\n       */\n      focus: (\n        position?: FocusPosition,\n        options?: {\n          scrollIntoView?: boolean,\n        },\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const focus: RawCommands['focus'] = (position = null, options = {}) => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  options = {\n    scrollIntoView: true,\n    ...options,\n  }\n\n  const delayedFocus = () => {\n    // focus within `requestAnimationFrame` breaks focus on iOS\n    // so we have to call this\n    if (isiOS()) {\n      (view.dom as HTMLElement).focus()\n    }\n\n    // For React we have to focus asynchronously. Otherwise wild things happen.\n    // see: https://github.com/ueberdosis/tiptap/issues/1520\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus()\n\n        if (options?.scrollIntoView) {\n          editor.commands.scrollIntoView()\n        }\n      }\n    })\n  }\n\n  if ((view.hasFocus() && position === null) || position === false) {\n    return true\n  }\n\n  // we don’t try to resolve a NodeSelection or CellSelection\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus()\n    return true\n  }\n\n  // pass through tr.doc instead of editor.state.doc\n  // since transactions could change the editors state before this command has been run\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection\n  const isSameSelection = editor.state.selection.eq(selection)\n\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection)\n    }\n\n    // `tr.setSelection` resets the stored marks\n    // so we’ll restore them if the selection is the same as before\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks)\n    }\n\n    delayedFocus()\n  }\n\n  return true\n}\n","import { CommandProps, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    forEach: {\n      /**\n       * Loop through an array of items.\n       */\n      forEach: <T>(\n        items: T[],\n        fn: (\n          item: T,\n          props: CommandProps & {\n            index: number,\n          },\n        ) => boolean,\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const forEach: RawCommands['forEach'] = (items, fn) => props => {\n  return items.every((item, index) => fn(item, { ...props, index }))\n}\n","import { ParseOptions } from '@tiptap/pm/model'\n\nimport { Content, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContent: {\n      /**\n       * Insert a node or string of HTML at the current position.\n       */\n      insertContent: (\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions\n          updateSelection?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const insertContent: RawCommands['insertContent'] = (value, options) => ({ tr, commands }) => {\n  return commands.insertContentAt(\n    { from: tr.selection.from, to: tr.selection.to },\n    value,\n    options,\n  )\n}\n","export function elementFromString(value: string): HTMLElement {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`\n\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body\n}\n","import {\n  DOMParser,\n  Fragment,\n  Node as ProseMirrorNode,\n  ParseOptions,\n  Schema,\n} from '@tiptap/pm/model'\n\nimport { Content } from '../types'\nimport { elementFromString } from '../utilities/elementFromString'\n\nexport type CreateNodeFromContentOptions = {\n  slice?: boolean\n  parseOptions?: ParseOptions\n}\n\nexport function createNodeFromContent(\n  content: Content,\n  schema: Schema,\n  options?: CreateNodeFromContentOptions,\n): ProseMirrorNode | Fragment {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options,\n  }\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content) && content.length > 0) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)))\n      }\n\n      return schema.nodeFromJSON(content)\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error)\n\n      return createNodeFromContent('', schema, options)\n    }\n  }\n\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema)\n\n    return options.slice\n      ? parser.parseSlice(elementFromString(content), options.parseOptions).content\n      : parser.parse(elementFromString(content), options.parseOptions)\n  }\n\n  return createNodeFromContent('', schema, options)\n}\n","import { Selection, Transaction } from '@tiptap/pm/state'\nimport { ReplaceAroundStep, ReplaceStep } from '@tiptap/pm/transform'\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nexport function selectionToInsertionEnd(tr: Transaction, startLen: number, bias: number) {\n  const last = tr.steps.length - 1\n\n  if (last < startLen) {\n    return\n  }\n\n  const step = tr.steps[last]\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return\n  }\n\n  const map = tr.mapping.maps[last]\n  let end = 0\n\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo\n    }\n  })\n\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import { Fragment, Node as ProseMirrorNode, ParseOptions } from '@tiptap/pm/model'\n\nimport { createNodeFromContent } from '../helpers/createNodeFromContent'\nimport { selectionToInsertionEnd } from '../helpers/selectionToInsertionEnd'\nimport { Content, Range, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContentAt: {\n      /**\n       * Insert a node or string of HTML at a specific position.\n       */\n      insertContentAt: (\n        position: number | Range,\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions\n          updateSelection?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nconst isFragment = (nodeOrFragment: ProseMirrorNode | Fragment): nodeOrFragment is Fragment => {\n  return nodeOrFragment.toString().startsWith('<')\n}\n\nexport const insertContentAt: RawCommands['insertContentAt'] = (position, value, options) => ({ tr, dispatch, editor }) => {\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options,\n    }\n\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions,\n      },\n    })\n\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true\n    }\n\n    let { from, to } = typeof position === 'number' ? { from: position, to: position } : position\n\n    let isOnlyTextContent = true\n    let isOnlyBlockContent = true\n    const nodes = isFragment(content) ? content : [content]\n\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check()\n\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false\n\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false\n    })\n\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const { parent } = tr.doc.resolve(from)\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount\n\n      if (isEmptyTextBlock) {\n        from -= 1\n        to += 1\n      }\n    }\n\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      // if value is string, we can use it directly\n      // otherwise if it is an array, we have to join it\n      if (Array.isArray(value)) {\n        tr.insertText(value.map(v => v.text || '').join(''), from, to)\n      } else if (typeof value === 'object' && !!value && !!value.text) {\n        tr.insertText(value.text, from, to)\n      } else {\n        tr.insertText(value as string, from, to)\n      }\n    } else {\n      tr.replaceWith(from, to, content)\n    }\n\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1)\n    }\n  }\n\n  return true\n}\n","import {\n  joinBackward as originalJoinBackward,\n  joinDown as originalJoinDown,\n  joinForward as originalJoinForward,\n  joinUp as originalJoinUp,\n} from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinUp: {\n      /**\n       * Join two nodes Up.\n       */\n      joinUp: () => ReturnType\n    }\n    joinDown: {\n      /**\n       * Join two nodes Down.\n       */\n      joinDown: () => ReturnType\n    }\n    joinBackward: {\n      /**\n       * Join two nodes Backwards.\n       */\n      joinBackward: () => ReturnType\n    }\n    joinForward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinUp: RawCommands['joinUp'] = () => ({ state, dispatch }) => {\n  return originalJoinUp(state, dispatch)\n}\n\nexport const joinDown: RawCommands['joinDown'] = () => ({ state, dispatch }) => {\n  return originalJoinDown(state, dispatch)\n}\n\nexport const joinBackward: RawCommands['joinBackward'] = () => ({ state, dispatch }) => {\n  return originalJoinBackward(state, dispatch)\n}\n\nexport const joinForward: RawCommands['joinForward'] = () => ({ state, dispatch }) => {\n  return originalJoinForward(state, dispatch)\n}\n","export function isMacOS(): boolean {\n  return typeof navigator !== 'undefined'\n    ? /Mac/.test(navigator.platform)\n    : false\n}\n","import { RawCommands } from '../types'\nimport { isiOS } from '../utilities/isiOS'\nimport { isMacOS } from '../utilities/isMacOS'\n\nfunction normalizeKeyName(name: string) {\n  const parts = name.split(/-(?!$)/)\n  let result = parts[parts.length - 1]\n\n  if (result === 'Space') {\n    result = ' '\n  }\n\n  let alt\n  let ctrl\n  let shift\n  let meta\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i]\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true\n      } else {\n        ctrl = true\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`)\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`\n  }\n\n  if (meta) {\n    result = `Meta-${result}`\n  }\n\n  if (shift) {\n    result = `Shift-${result}`\n  }\n\n  return result\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    keyboardShortcut: {\n      /**\n       * Trigger a keyboard shortcut.\n       */\n      keyboardShortcut: (name: string) => ReturnType,\n    }\n  }\n}\n\nexport const keyboardShortcut: RawCommands['keyboardShortcut'] = name => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/)\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item))\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space'\n      ? ' '\n      : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true,\n  })\n\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event))\n  })\n\n  capturedTransaction?.steps.forEach(step => {\n    const newStep = step.map(tr.mapping)\n\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep)\n    }\n  })\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { NodeRange } from '../types'\nimport { objectIncludes } from '../utilities/objectIncludes'\nimport { getNodeType } from './getNodeType'\n\nexport function isNodeActive(\n  state: EditorState,\n  typeOrName: NodeType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null\n\n  const nodeRanges: NodeRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return\n    }\n\n    const relativeFrom = Math.max(from, pos)\n    const relativeTo = Math.min(to, pos + node.nodeSize)\n\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo,\n    })\n  })\n\n  const selectionRange = to - from\n  const matchedNodeRanges = nodeRanges\n    .filter(nodeRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === nodeRange.node.type.name\n    })\n    .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }))\n\n  if (empty) {\n    return !!matchedNodeRanges.length\n  }\n\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0)\n\n  return range >= selectionRange\n}\n","import { lift as originalLift } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isNodeActive } from '../helpers/isNodeActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    lift: {\n      /**\n       * Removes an existing wrap.\n       */\n      lift: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const lift: RawCommands['lift'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (!isActive) {\n    return false\n  }\n\n  return originalLift(state, dispatch)\n}\n","import { liftEmptyBlock as originalLiftEmptyBlock } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftEmptyBlock: {\n      /**\n       * Lift block if empty.\n       */\n      liftEmptyBlock: () => ReturnType,\n    }\n  }\n}\n\nexport const liftEmptyBlock: RawCommands['liftEmptyBlock'] = () => ({ state, dispatch }) => {\n  return originalLiftEmptyBlock(state, dispatch)\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { liftListItem as originalLiftListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftListItem: {\n      /**\n       * Lift the list item into a wrapping list.\n       */\n      liftListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const liftListItem: RawCommands['liftListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalLiftListItem(type)(state, dispatch)\n}\n","import { newlineInCode as originalNewlineInCode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    newlineInCode: {\n      /**\n       * Add a newline character in code.\n       */\n      newlineInCode: () => ReturnType\n    }\n  }\n}\n\nexport const newlineInCode: RawCommands['newlineInCode'] = () => ({ state, dispatch }) => {\n  return originalNewlineInCode(state, dispatch)\n}\n","import { Schema } from '@tiptap/pm/model'\n\nexport function getSchemaTypeNameByName(name: string, schema: Schema): 'node' | 'mark' | null {\n  if (schema.nodes[name]) {\n    return 'node'\n  }\n\n  if (schema.marks[name]) {\n    return 'mark'\n  }\n\n  return null\n}\n","/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nexport function deleteProps(obj: Record<string, any>, propOrProps: string | string[]): Record<string, any> {\n  const props = typeof propOrProps === 'string'\n    ? [propOrProps]\n    : propOrProps\n\n  return Object\n    .keys(obj)\n    .reduce((newObj: Record<string, any>, prop) => {\n      if (!props.includes(prop)) {\n        newObj[prop] = obj[prop]\n      }\n\n      return newObj\n    }, {})\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType'\nimport { getNodeType } from '../helpers/getNodeType'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName'\nimport { RawCommands } from '../types'\nimport { deleteProps } from '../utilities/deleteProps'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    resetAttributes: {\n      /**\n       * Resets some node attributes to the default value.\n       */\n      resetAttributes: (\n        typeOrName: string | NodeType | MarkType,\n        attributes: string | string[],\n      ) => ReturnType\n    }\n  }\n}\n\nexport const resetAttributes: RawCommands['resetAttributes'] = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes))\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(\n                pos,\n                pos + node.nodeSize,\n                markType.create(deleteProps(mark.attrs, attributes)),\n              )\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    scrollIntoView: {\n      /**\n       * Scroll the selection into view.\n       */\n      scrollIntoView: () => ReturnType,\n    }\n  }\n}\n\nexport const scrollIntoView: RawCommands['scrollIntoView'] = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectAll: {\n      /**\n       * Select the whole document.\n       */\n      selectAll: () => ReturnType,\n    }\n  }\n}\n\nexport const selectAll: RawCommands['selectAll'] = () => ({ tr, commands }) => {\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size,\n  })\n}\n","import { selectNodeBackward as originalSelectNodeBackward } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeBackward: {\n      /**\n       * Select a node backward.\n       */\n      selectNodeBackward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeBackward: RawCommands['selectNodeBackward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeBackward(state, dispatch)\n}\n","import { selectNodeForward as originalSelectNodeForward } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeForward: {\n      /**\n       * Select a node forward.\n       */\n      selectNodeForward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeForward: RawCommands['selectNodeForward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeForward(state, dispatch)\n}\n","import { selectParentNode as originalSelectParentNode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectParentNode: {\n      /**\n       * Select the parent node.\n       */\n      selectParentNode: () => ReturnType\n    }\n  }\n}\n\nexport const selectParentNode: RawCommands['selectParentNode'] = () => ({ state, dispatch }) => {\n  return originalSelectParentNode(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockEnd as originalSelectTextblockEnd } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockEnd: {\n      /**\n       * Moves the cursor to the end of current text block.\n       */\n      selectTextblockEnd: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockEnd: RawCommands['selectTextblockEnd'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockEnd(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockStart as originalSelectTextblockStart } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockStart: {\n      /**\n       * Moves the cursor to the start of current text block.\n       */\n      selectTextblockStart: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockStart: RawCommands['selectTextblockStart'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockStart(state, dispatch)\n}\n","import { Node as ProseMirrorNode, ParseOptions, Schema } from '@tiptap/pm/model'\n\nimport { Content } from '../types'\nimport { createNodeFromContent } from './createNodeFromContent'\n\nexport function createDocument(\n  content: Content,\n  schema: Schema,\n  parseOptions: ParseOptions = {},\n): ProseMirrorNode {\n  return createNodeFromContent(content, schema, { slice: false, parseOptions }) as ProseMirrorNode\n}\n","import { ParseOptions } from '@tiptap/pm/model'\n\nimport { createDocument } from '../helpers/createDocument'\nimport { Content, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setContent: {\n      /**\n       * Replace the whole document with new content.\n       */\n      setContent: (\n        content: Content,\n        emitUpdate?: boolean,\n        parseOptions?: ParseOptions,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const setContent: RawCommands['setContent'] = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\n  const { doc } = tr\n  const document = createDocument(content, editor.schema, parseOptions)\n\n  if (dispatch) {\n    tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate)\n  }\n\n  return true\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Transaction } from '@tiptap/pm/state'\nimport { Transform } from '@tiptap/pm/transform'\n\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n */\nexport function combineTransactionSteps(\n  oldDoc: ProseMirrorNode,\n  transactions: Transaction[],\n): Transform {\n  const transform = new Transform(oldDoc)\n\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step)\n    })\n  })\n\n  return transform\n}\n","import { ContentMatch, NodeType } from '@tiptap/pm/model'\n\nexport function defaultBlockAt(match: ContentMatch): NodeType | null {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i)\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type\n    }\n  }\n\n  return null\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { NodeWithPos, Predicate } from '../types'\n\nexport function findChildren(node: ProseMirrorNode, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { NodeWithPos, Predicate, Range } from '../types'\n\n/**\n * Same as `findChildren` but searches only within a `range`.\n */\nexport function findChildrenInRange(\n  node: ProseMirrorNode,\n  range: Range,\n  predicate: Predicate,\n): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode, ResolvedPos } from '@tiptap/pm/model'\n\nimport { Predicate } from '../types'\n\nexport function findParentNodeClosestToPos(\n  $pos: ResolvedPos,\n  predicate: Predicate,\n):\n  | {\n      pos: number\n      start: number\n      depth: number\n      node: ProseMirrorNode\n    }\n  | undefined {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i)\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      }\n    }\n  }\n}\n","import { Selection } from '@tiptap/pm/state'\n\nimport { Predicate } from '../types'\nimport { findParentNodeClosestToPos } from './findParentNodeClosestToPos'\n\nexport function findParentNode(predicate: Predicate) {\n  return (selection: Selection) => findParentNodeClosestToPos(selection.$from, predicate)\n}\n","import { DOMSerializer, Fragment, Schema } from '@tiptap/pm/model'\n\nexport function getHTMLFromFragment(fragment: Fragment, schema: Schema): string {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment)\n\n  const temporaryDocument = document.implementation.createHTMLDocument()\n  const container = temporaryDocument.createElement('div')\n\n  container.appendChild(documentFragment)\n\n  return container.innerHTML\n}\n","import { Schema } from '@tiptap/pm/model'\n\nimport { Editor } from '../Editor'\nimport { ExtensionManager } from '../ExtensionManager'\nimport { Extensions } from '../types'\nimport { getSchemaByResolvedExtensions } from './getSchemaByResolvedExtensions'\n\nexport function getSchema(extensions: Extensions, editor?: Editor): Schema {\n  const resolvedExtensions = ExtensionManager.resolve(extensions)\n\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor)\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport { Extensions, JSONContent } from '../types'\nimport { getHTMLFromFragment } from './getHTMLFromFragment'\nimport { getSchema } from './getSchema'\n\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode.content, schema)\n}\n","import { DOMParser } from '@tiptap/pm/model'\n\nimport { Extensions } from '../types'\nimport { elementFromString } from '../utilities/elementFromString'\nimport { getSchema } from './getSchema'\n\nexport function generateJSON(html: string, extensions: Extensions): Record<string, any> {\n  const schema = getSchema(extensions)\n  const dom = elementFromString(html)\n\n  return DOMParser.fromSchema(schema).parse(dom).toJSON()\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { TextSerializer } from '../types'\nimport { getTextBetween } from './getTextBetween'\n\nexport function getText(\n  node: ProseMirrorNode,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n) {\n  const range = {\n    from: 0,\n    to: node.content.size,\n  }\n\n  return getTextBetween(node, range, options)\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport { Extensions, JSONContent, TextSerializer } from '../types'\nimport { getSchema } from './getSchema'\nimport { getText } from './getText'\nimport { getTextSerializersFromSchema } from './getTextSerializersFromSchema'\n\nexport function generateText(\n  doc: JSONContent,\n  extensions: Extensions,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers,\n    },\n  })\n}\n","import { Mark, MarkType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkType } from './getMarkType'\n\nexport function getMarkAttributes(\n  state: EditorState,\n  typeOrName: string | MarkType,\n): Record<string, any> {\n  const type = getMarkType(typeOrName, state.schema)\n  const { from, to, empty } = state.selection\n  const marks: Mark[] = []\n\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks)\n    }\n\n    marks.push(...state.selection.$head.marks())\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks)\n    })\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name)\n\n  if (!mark) {\n    return {}\n  }\n\n  return { ...mark.attrs }\n}\n","import { Node, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getNodeType } from './getNodeType'\n\nexport function getNodeAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType,\n): Record<string, any> {\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = state.selection\n  const nodes: Node[] = []\n\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node)\n  })\n\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name)\n\n  if (!node) {\n    return {}\n  }\n\n  return { ...node.attrs }\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkAttributes } from './getMarkAttributes'\nimport { getNodeAttributes } from './getNodeAttributes'\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName'\n\nexport function getAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType | MarkType,\n): Record<string, any> {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName as NodeType)\n  }\n\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName as MarkType)\n  }\n\n  return {}\n}\n","/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nexport function removeDuplicates<T>(array: T[], by = JSON.stringify): T[] {\n  const seen: Record<any, any> = {}\n\n  return array.filter(item => {\n    const key = by(item)\n\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true)\n  })\n}\n","import { Step, Transform } from '@tiptap/pm/transform'\n\nimport { Range } from '../types'\nimport { removeDuplicates } from '../utilities/removeDuplicates'\n\nexport type ChangedRange = {\n  oldRange: Range,\n  newRange: Range,\n}\n\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */\nfunction simplifyChangedRanges(changes: ChangedRange[]): ChangedRange[] {\n  const uniqueChanges = removeDuplicates(changes)\n\n  return uniqueChanges.length === 1\n    ? uniqueChanges\n    : uniqueChanges.filter((change, index) => {\n      const rest = uniqueChanges.filter((_, i) => i !== index)\n\n      return !rest.some(otherChange => {\n        return change.oldRange.from >= otherChange.oldRange.from\n          && change.oldRange.to <= otherChange.oldRange.to\n          && change.newRange.from >= otherChange.newRange.from\n          && change.newRange.to <= otherChange.newRange.to\n      })\n    })\n}\n\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */\nexport function getChangedRanges(transform: Transform): ChangedRange[] {\n  const { mapping, steps } = transform\n  const changes: ChangedRange[] = []\n\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges: Range[] = []\n\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index] as Step & {\n        from?: number,\n        to?: number,\n      }\n\n      if (from === undefined || to === undefined) {\n        return\n      }\n\n      ranges.push({ from, to })\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to })\n      })\n    }\n\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1)\n      const newEnd = mapping.slice(index).map(to)\n      const oldStart = mapping.invert().map(newStart, -1)\n      const oldEnd = mapping.invert().map(newEnd)\n\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd,\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd,\n        },\n      })\n    })\n  })\n\n  return simplifyChangedRanges(changes)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { JSONContent } from '../types'\n\ninterface DebugJSONContent extends JSONContent {\n  from: number\n  to: number\n}\n\nexport function getDebugJSON(node: ProseMirrorNode, startOffset = 0): DebugJSONContent {\n  const isTopNode = node.type === node.type.schema.topNodeType\n  const increment = isTopNode ? 0 : 1\n  const from = startOffset\n  const to = from + node.nodeSize\n  const marks = node.marks.map(mark => {\n    const output: { type: string; attrs?: Record<string, any> } = {\n      type: mark.type.name,\n    }\n\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = { ...mark.attrs }\n    }\n\n    return output\n  })\n  const attrs = { ...node.attrs }\n  const output: DebugJSONContent = {\n    type: node.type.name,\n    from,\n    to,\n  }\n\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs\n  }\n\n  if (marks.length) {\n    output.marks = marks\n  }\n\n  if (node.content.childCount) {\n    output.content = []\n\n    node.forEach((child, offset) => {\n      output.content?.push(getDebugJSON(child, startOffset + offset + increment))\n    })\n  }\n\n  if (node.text) {\n    output.text = node.text\n  }\n\n  return output\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { MarkRange } from '../types'\nimport { getMarkRange } from './getMarkRange'\n\nexport function getMarksBetween(from: number, to: number, doc: ProseMirrorNode): MarkRange[] {\n  const marks: MarkRange[] = []\n\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc\n      .resolve(from)\n      .marks()\n      .forEach(mark => {\n        const $pos = doc.resolve(from - 1)\n        const range = getMarkRange($pos, mark.type)\n\n        if (!range) {\n          return\n        }\n\n        marks.push({\n          mark,\n          ...range,\n        })\n      })\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(\n        ...node.marks.map(mark => ({\n          from: pos,\n          to: pos + node.nodeSize,\n          mark,\n        })),\n      )\n    })\n  }\n\n  return marks\n}\n","import { ExtensionAttribute } from '../types'\n\nexport function getSplittedAttributes(\n  extensionAttributes: ExtensionAttribute[],\n  typeName: string,\n  attributes: Record<string, any>,\n): Record<string, any> {\n  return Object.fromEntries(Object\n    .entries(attributes)\n    .filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find(item => {\n        return item.type === typeName && item.name === name\n      })\n\n      if (!extensionAttribute) {\n        return false\n      }\n\n      return extensionAttribute.attribute.keepOnSplit\n    }))\n}\n","import { MarkType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { MarkRange } from '../types'\nimport { objectIncludes } from '../utilities/objectIncludes'\nimport { getMarkType } from './getMarkType'\n\nexport function isMarkActive(\n  state: EditorState,\n  typeOrName: MarkType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { empty, ranges } = state.selection\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks())\n      .filter(mark => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === mark.type.name\n      })\n      .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }))\n  }\n\n  let selectionRange = 0\n  const markRanges: MarkRange[] = []\n\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos\n    const to = $to.pos\n\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return\n      }\n\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n      const range = relativeTo - relativeFrom\n\n      selectionRange += range\n\n      markRanges.push(\n        ...node.marks.map(mark => ({\n          mark,\n          from: relativeFrom,\n          to: relativeTo,\n        })),\n      )\n    })\n  })\n\n  if (selectionRange === 0) {\n    return false\n  }\n\n  // calculate range of matched mark\n  const matchedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === markRange.mark.type.name\n    })\n    .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return markRange.mark.type !== type && markRange.mark.type.excludes(type)\n    })\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange\n\n  return range >= selectionRange\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName'\nimport { isMarkActive } from './isMarkActive'\nimport { isNodeActive } from './isNodeActive'\n\nexport function isActive(\n  state: EditorState,\n  name: string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes)\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema)\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes)\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes)\n  }\n\n  return false\n}\n","import { NodeConfig } from '..'\nimport { getExtensionField } from '../helpers/getExtensionField'\nimport { Extensions } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\nimport { splitExtensions } from './splitExtensions'\n\nexport function isList(name: string, extensions: Extensions): boolean {\n  const { nodeExtensions } = splitExtensions(extensions)\n  const extension = nodeExtensions.find(item => item.name === name)\n\n  if (!extension) {\n    return false\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage,\n  }\n  const group = callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context))\n\n  if (typeof group !== 'string') {\n    return false\n  }\n\n  return group.split(' ').includes('list')\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport function isNodeEmpty(node: ProseMirrorNode): boolean {\n  const defaultContent = node.type.createAndFill()?.toJSON()\n  const content = node.toJSON()\n\n  return JSON.stringify(defaultContent) === JSON.stringify(content)\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nexport function isNodeSelection(value: unknown): value is NodeSelection {\n  return value instanceof NodeSelection\n}\n","import { EditorView } from '@tiptap/pm/view'\n\nimport { minMax } from '../utilities/minMax'\n\nexport function posToDOMRect(view: EditorView, from: number, to: number): DOMRect {\n  const minPos = 0\n  const maxPos = view.state.doc.content.size\n  const resolvedFrom = minMax(from, minPos, maxPos)\n  const resolvedEnd = minMax(to, minPos, maxPos)\n  const start = view.coordsAtPos(resolvedFrom)\n  const end = view.coordsAtPos(resolvedEnd, -1)\n  const top = Math.min(start.top, end.top)\n  const bottom = Math.max(start.bottom, end.bottom)\n  const left = Math.min(start.left, end.left)\n  const right = Math.max(start.right, end.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y,\n  }\n\n  return {\n    ...data,\n    toJSON: () => data,\n  }\n}\n","import { MarkType, ResolvedPos } from '@tiptap/pm/model'\nimport { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { isTextSelection } from '../helpers'\nimport { getMarkAttributes } from '../helpers/getMarkAttributes'\nimport { getMarkType } from '../helpers/getMarkType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMark: {\n      /**\n       * Add a mark with new attributes.\n       */\n      setMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nfunction canSetMark(state: EditorState, tr: Transaction, newMarkType: MarkType) {\n  const { selection } = tr\n  let cursor: ResolvedPos | null = null\n\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor\n  }\n\n  if (cursor) {\n    const currentMarks = state.storedMarks ?? cursor.marks()\n\n    // There can be no current marks that exclude the new mark\n    return (\n      !!newMarkType.isInSet(currentMarks)\n      || !currentMarks.some(mark => mark.type.excludes(newMarkType))\n    )\n  }\n\n  const { ranges } = selection\n\n  return ranges.some(({ $from, $to }) => {\n    let someNodeSupportsMark = $from.depth === 0\n      ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType)\n      : false\n\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false\n      }\n\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType)\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks)\n          || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType))\n\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType\n      }\n      return !someNodeSupportsMark\n    })\n\n    return someNodeSupportsMark\n  })\n}\nexport const setMark: RawCommands['setMark'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n  const type = getMarkType(typeOrName, state.schema)\n\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type)\n\n      tr.addStoredMark(\n        type.create({\n          ...oldAttributes,\n          ...attributes,\n        }),\n      )\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos\n        const to = range.$to.pos\n\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from)\n          const trimmedTo = Math.min(pos + node.nodeSize, to)\n          const someHasMark = node.marks.find(mark => mark.type === type)\n\n          // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(\n                  trimmedFrom,\n                  trimmedTo,\n                  type.create({\n                    ...mark.attrs,\n                    ...attributes,\n                  }),\n                )\n              }\n            })\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes))\n          }\n        })\n      })\n    }\n  }\n\n  return canSetMark(state, tr, type)\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMeta: {\n      /**\n       * Store a metadata property in the current transaction.\n       */\n      setMeta: (key: string, value: any) => ReturnType,\n    }\n  }\n}\n\nexport const setMeta: RawCommands['setMeta'] = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value)\n\n  return true\n}\n","import { setBlockType } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNode: {\n      /**\n       * Replace a given range with a node.\n       */\n      setNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const setNode: RawCommands['setNode'] = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  // TODO: use a fallback like insertContent?\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.')\n\n    return false\n  }\n\n  return (\n    chain()\n    // try to convert node to default node if needed\n      .command(({ commands }) => {\n        const canSetBlock = setBlockType(type, attributes)(state)\n\n        if (canSetBlock) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .command(({ state: updatedState }) => {\n        return setBlockType(type, attributes)(updatedState, dispatch)\n      })\n      .run()\n  )\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nimport { RawCommands } from '../types'\nimport { minMax } from '../utilities/minMax'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNodeSelection: {\n      /**\n       * Creates a NodeSelection.\n       */\n      setNodeSelection: (position: number) => ReturnType\n    }\n  }\n}\n\nexport const setNodeSelection: RawCommands['setNodeSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const from = minMax(position, 0, doc.content.size)\n    const selection = NodeSelection.create(doc, from)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nimport { Range, RawCommands } from '../types'\nimport { minMax } from '../utilities/minMax'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setTextSelection: {\n      /**\n       * Creates a TextSelection.\n       */\n      setTextSelection: (position: number | Range) => ReturnType\n    }\n  }\n}\n\nexport const setTextSelection: RawCommands['setTextSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const { from, to } = typeof position === 'number' ? { from: position, to: position } : position\n    const minPos = TextSelection.atStart(doc).from\n    const maxPos = TextSelection.atEnd(doc).to\n    const resolvedFrom = minMax(from, minPos, maxPos)\n    const resolvedEnd = minMax(to, minPos, maxPos)\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { sinkListItem as originalSinkListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    sinkListItem: {\n      /**\n       * Sink the list item down into an inner list.\n       */\n      sinkListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const sinkListItem: RawCommands['sinkListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalSinkListItem(type)(state, dispatch)\n}\n","import { EditorState, NodeSelection, TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { defaultBlockAt } from '../helpers/defaultBlockAt'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes'\nimport { RawCommands } from '../types'\n\nfunction ensureMarks(state: EditorState, splittableMarks?: string[]) {\n  const marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks?.includes(mark.type.name))\n\n    state.tr.ensureMarks(filteredMarks)\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitBlock: {\n      /**\n       * Forks a new node from an existing node.\n       */\n      splitBlock: (options?: { keepMarks?: boolean }) => ReturnType\n    }\n  }\n}\n\nexport const splitBlock: RawCommands['splitBlock'] = ({ keepMarks = true } = {}) => ({\n  tr, state, dispatch, editor,\n}) => {\n  const { selection, doc } = tr\n  const { $from, $to } = selection\n  const extensionAttributes = editor.extensionManager.attributes\n  const newAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false\n    }\n\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks)\n      }\n\n      tr.split($from.pos).scrollIntoView()\n    }\n\n    return true\n  }\n\n  if (!$from.parent.isBlock) {\n    return false\n  }\n\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size\n\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection()\n    }\n\n    const deflt = $from.depth === 0\n      ? undefined\n      : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n\n    let types = atEnd && deflt\n      ? [\n        {\n          type: deflt,\n          attrs: newAttributes,\n        },\n      ]\n      : undefined\n\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n\n    if (\n      !types\n        && !can\n        && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)\n    ) {\n      can = true\n      types = deflt\n        ? [\n          {\n            type: deflt,\n            attrs: newAttributes,\n          },\n        ]\n        : undefined\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first = tr.mapping.map($from.before())\n        const $first = tr.doc.resolve(first)\n\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n        }\n      }\n    }\n\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks)\n    }\n\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import {\n  Fragment, Node as ProseMirrorNode, NodeType, Slice,\n} from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitListItem: {\n      /**\n       * Splits one list item into two list items.\n       */\n      splitListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const splitListItem: RawCommands['splitListItem'] = typeOrName => ({\n  tr, state, dispatch, editor,\n}) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const { $from, $to } = state.selection\n\n  // @ts-ignore\n  // eslint-disable-next-line\n    const node: ProseMirrorNode = state.selection.node\n\n  if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n    return false\n  }\n\n  const grandParent = $from.node(-1)\n\n  if (grandParent.type !== type) {\n    return false\n  }\n\n  const extensionAttributes = editor.extensionManager.attributes\n\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if (\n      $from.depth === 2\n        || $from.node(-3).type !== type\n        || $from.index(-2) !== $from.node(-2).childCount - 1\n    ) {\n      return false\n    }\n\n    if (dispatch) {\n      let wrap = Fragment.empty\n      // eslint-disable-next-line\n        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3\n\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap))\n      }\n\n      // eslint-disable-next-line\n        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3\n\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(\n        extensionAttributes,\n        $from.node().type.name,\n        $from.node().attrs,\n      )\n      const nextType = type.contentMatch.defaultType?.createAndFill(newNextTypeAttributes) || undefined\n\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined))\n\n      const start = $from.before($from.depth - (depthBefore - 1))\n\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0))\n\n      let sel = -1\n\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false\n        }\n\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1\n        }\n      })\n\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)))\n      }\n\n      tr.scrollIntoView()\n    }\n\n    return true\n  }\n\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null\n\n  const newTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    grandParent.type.name,\n    grandParent.attrs,\n  )\n  const newNextTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  tr.delete($from.pos, $to.pos)\n\n  const types = nextType\n    ? [\n      { type, attrs: newTypeAttributes },\n      { type: nextType, attrs: newNextTypeAttributes },\n    ]\n    : [{ type, attrs: newTypeAttributes }]\n\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false\n  }\n\n  if (dispatch) {\n    const { selection, storedMarks } = state\n    const { splittableMarks } = editor.extensionManager\n    const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n    tr.split($from.pos, 2, types).scrollIntoView()\n\n    if (!marks || !dispatch) {\n      return true\n    }\n\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n    tr.ensureMarks(filteredMarks)\n  }\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { Transaction } from '@tiptap/pm/state'\nimport { canJoin } from '@tiptap/pm/transform'\n\nimport { findParentNode } from '../helpers/findParentNode'\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isList } from '../helpers/isList'\nimport { RawCommands } from '../types'\n\nconst joinListBackwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth)\n\n  if (before === undefined) {\n    return true\n  }\n\n  const nodeBefore = tr.doc.nodeAt(before)\n  const canJoinBackwards = list.node.type === nodeBefore?.type && canJoin(tr.doc, list.pos)\n\n  if (!canJoinBackwards) {\n    return true\n  }\n\n  tr.join(list.pos)\n\n  return true\n}\n\nconst joinListForwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const after = tr.doc.resolve(list.start).after(list.depth)\n\n  if (after === undefined) {\n    return true\n  }\n\n  const nodeAfter = tr.doc.nodeAt(after)\n  const canJoinForwards = list.node.type === nodeAfter?.type && canJoin(tr.doc, after)\n\n  if (!canJoinForwards) {\n    return true\n  }\n\n  tr.join(after)\n\n  return true\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleList: {\n      /**\n       * Toggle between different list types.\n       */\n      toggleList: (listTypeOrName: string | NodeType, itemTypeOrName: string | NodeType, keepMarks?: boolean, attributes?: Record<string, any>) => ReturnType;\n    }\n  }\n}\n\nexport const toggleList: RawCommands['toggleList'] = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({\n  editor, tr, state, dispatch, chain, commands, can,\n}) => {\n  const { extensions, splittableMarks } = editor.extensionManager\n  const listType = getNodeType(listTypeOrName, state.schema)\n  const itemType = getNodeType(itemTypeOrName, state.schema)\n  const { selection, storedMarks } = state\n  const { $from, $to } = selection\n  const range = $from.blockRange($to)\n\n  const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n  if (!range) {\n    return false\n  }\n\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection)\n\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType)\n    }\n\n    // change list type\n    if (\n      isList(parentList.node.type.name, extensions)\n        && listType.validContent(parentList.node.content)\n        && dispatch\n    ) {\n      return chain()\n        .command(() => {\n          tr.setNodeMarkup(parentList.pos, listType)\n\n          return true\n        })\n        .command(() => joinListBackwards(tr, listType))\n        .command(() => joinListForwards(tr, listType))\n        .run()\n    }\n  }\n  if (!keepMarks || !marks || !dispatch) {\n\n    return chain()\n      // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes)\n\n        if (canWrapInList) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .wrapInList(listType, attributes)\n      .command(() => joinListBackwards(tr, listType))\n      .command(() => joinListForwards(tr, listType))\n      .run()\n  }\n\n  return (\n    chain()\n    // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes)\n\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n        tr.ensureMarks(filteredMarks)\n\n        if (canWrapInList) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .wrapInList(listType, attributes)\n      .command(() => joinListBackwards(tr, listType))\n      .command(() => joinListForwards(tr, listType))\n      .run()\n  )\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType'\nimport { isMarkActive } from '../helpers/isMarkActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleMark: {\n      /**\n       * Toggle a mark on and off.\n       */\n      toggleMark: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleMark: RawCommands['toggleMark'] = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n  const { extendEmptyMarkRange = false } = options\n  const type = getMarkType(typeOrName, state.schema)\n  const isActive = isMarkActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.unsetMark(type, { extendEmptyMarkRange })\n  }\n\n  return commands.setMark(type, attributes)\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isNodeActive } from '../helpers/isNodeActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleNode: {\n      /**\n       * Toggle a node with another node.\n       */\n      toggleNode: (\n        typeOrName: string | NodeType,\n        toggleTypeOrName: string | NodeType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleNode: RawCommands['toggleNode'] = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const toggleType = getNodeType(toggleTypeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.setNode(toggleType)\n  }\n\n  return commands.setNode(type, attributes)\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isNodeActive } from '../helpers/isNodeActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleWrap: {\n      /**\n       * Wraps nodes in another node, or removes an existing wrap.\n       */\n      toggleWrap: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const toggleWrap: RawCommands['toggleWrap'] = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.lift(type)\n  }\n\n  return commands.wrapIn(type, attributes)\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    undoInputRule: {\n      /**\n       * Undo an input rule.\n       */\n      undoInputRule: () => ReturnType,\n    }\n  }\n}\n\nexport const undoInputRule: RawCommands['undoInputRule'] = () => ({ state, dispatch }) => {\n  const plugins = state.plugins\n\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i]\n    let undoable\n\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr\n        const toUndo = undoable.transform\n\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        }\n\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks()\n\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetAllMarks: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetAllMarks: () => ReturnType,\n    }\n  }\n}\n\nexport const unsetAllMarks: RawCommands['unsetAllMarks'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n\n  if (empty) {\n    return true\n  }\n\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos)\n    })\n  }\n\n  return true\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkRange } from '../helpers/getMarkRange'\nimport { getMarkType } from '../helpers/getMarkType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetMark: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetMark: (\n        typeOrName: string | MarkType,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const unsetMark: RawCommands['unsetMark'] = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n  const { extendEmptyMarkRange = false } = options\n  const { selection } = tr\n  const type = getMarkType(typeOrName, state.schema)\n  const { $from, empty, ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  if (empty && extendEmptyMarkRange) {\n    let { from, to } = selection\n    const attrs = $from.marks().find(mark => mark.type === type)?.attrs\n    const range = getMarkRange($from, type, attrs)\n\n    if (range) {\n      from = range.from\n      to = range.to\n    }\n\n    tr.removeMark(from, to, type)\n  } else {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type)\n    })\n  }\n\n  tr.removeStoredMark(type)\n\n  return true\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType'\nimport { getNodeType } from '../helpers/getNodeType'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    updateAttributes: {\n      /**\n       * Update attributes of a node or mark.\n       */\n      updateAttributes: (\n        typeOrName: string | NodeType | MarkType,\n        attributes: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const updateAttributes: RawCommands['updateAttributes'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos\n      const to = range.$to.pos\n\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, {\n            ...node.attrs,\n            ...attributes,\n          })\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from)\n              const trimmedTo = Math.min(pos + node.nodeSize, to)\n\n              tr.addMark(\n                trimmedFrom,\n                trimmedTo,\n                markType.create({\n                  ...mark.attrs,\n                  ...attributes,\n                }),\n              )\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { wrapIn as originalWrapIn } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapIn: {\n      /**\n       * Wraps nodes in another node.\n       */\n      wrapIn: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapIn: RawCommands['wrapIn'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapIn(type, attributes)(state, dispatch)\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { wrapInList as originalWrapInList } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapInList: {\n      /**\n       * Wrap a node in a list.\n       */\n      wrapInList: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapInList: RawCommands['wrapInList'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapInList(type, attributes)(state, dispatch)\n}\n","import * as commands from '../commands'\nimport { Extension } from '../Extension'\n\nexport * from '../commands'\n\nexport const Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return {\n      ...commands,\n    }\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension'\n\nexport const Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('editable'),\n        props: {\n          editable: () => this.editor.options.editable,\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension'\n\nexport const FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const { editor } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('focusEvents'),\n        props: {\n          handleDOMEvents: {\n            focus: (view, event: Event) => {\n              editor.isFocused = true\n\n              const transaction = editor.state.tr\n                .setMeta('focus', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n            blur: (view, event: Event) => {\n              editor.isFocused = false\n\n              const transaction = editor.state.tr\n                .setMeta('blur', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey, Selection } from '@tiptap/pm/state'\n\nimport { CommandManager } from '../CommandManager'\nimport { Extension } from '../Extension'\nimport { createChainableState } from '../helpers/createChainableState'\nimport { isiOS } from '../utilities/isiOS'\nimport { isMacOS } from '../utilities/isMacOS'\n\nexport const Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n      // maybe convert first text block node to default node\n      () => commands.command(({ tr }) => {\n        const { selection, doc } = tr\n        const { empty, $anchor } = selection\n        const { pos, parent } = $anchor\n        const isAtStart = Selection.atStart(doc).from === pos\n\n        if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n          return false\n        }\n\n        return commands.clearNodes()\n      }),\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward(),\n    ])\n\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.deleteCurrentNode(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward(),\n    ])\n\n    const handleEnter = () => this.editor.commands.first(({ commands }) => [\n      () => commands.newlineInCode(),\n      () => commands.createParagraphNear(),\n      () => commands.liftEmptyBlock(),\n      () => commands.splitBlock(),\n    ])\n\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll(),\n    }\n\n    const pcKeymap = {\n      ...baseKeymap,\n    }\n\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\n    }\n\n    if (isiOS() || isMacOS()) {\n      return macKeymap\n    }\n\n    return pcKeymap\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // With this plugin we check if the whole document was selected and deleted.\n      // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n      // to a paragraph if necessary.\n      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n      // with many other commands.\n      new Plugin({\n        key: new PluginKey('clearDocument'),\n        appendTransaction: (transactions, oldState, newState) => {\n          const docChanges = transactions.some(transaction => transaction.docChanged)\n            && !oldState.doc.eq(newState.doc)\n\n          if (!docChanges) {\n            return\n          }\n\n          const { empty, from, to } = oldState.selection\n          const allFrom = Selection.atStart(oldState.doc).from\n          const allEnd = Selection.atEnd(oldState.doc).to\n          const allWasSelected = from === allFrom && to === allEnd\n\n          if (empty || !allWasSelected) {\n            return\n          }\n\n          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0\n\n          if (!isEmpty) {\n            return\n          }\n\n          const tr = newState.tr\n          const state = createChainableState({\n            state: newState,\n            transaction: tr,\n          })\n          const { commands } = new CommandManager({\n            editor: this.editor,\n            state,\n          })\n\n          commands.clearNodes()\n\n          if (!tr.steps.length) {\n            return\n          }\n\n          return tr\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension'\n\nexport const Tabindex = Extension.create({\n  name: 'tabindex',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('tabindex'),\n        props: {\n          attributes: this.editor.isEditable ? { tabindex: '0' } : {},\n        },\n      }),\n    ]\n  },\n})\n","export const style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`\n","export function createStyleTag(style: string, nonce?: string): HTMLStyleElement {\n  const tiptapStyleTag = (<HTMLStyleElement>document.querySelector('style[data-tiptap-style]'))\n\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag\n  }\n\n  const styleNode = document.createElement('style')\n\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce)\n  }\n\n  styleNode.setAttribute('data-tiptap-style', '')\n  styleNode.innerHTML = style\n  document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  return styleNode\n}\n","import { MarkType, NodeType, Schema } from '@tiptap/pm/model'\nimport {\n  EditorState, Plugin, PluginKey, Transaction,\n} from '@tiptap/pm/state'\nimport { EditorView } from '@tiptap/pm/view'\n\nimport { CommandManager } from './CommandManager'\nimport { EventEmitter } from './EventEmitter'\nimport { ExtensionManager } from './ExtensionManager'\nimport * as extensions from './extensions'\nimport { createDocument } from './helpers/createDocument'\nimport { getAttributes } from './helpers/getAttributes'\nimport { getHTMLFromFragment } from './helpers/getHTMLFromFragment'\nimport { getText } from './helpers/getText'\nimport { getTextSerializersFromSchema } from './helpers/getTextSerializersFromSchema'\nimport { isActive } from './helpers/isActive'\nimport { isNodeEmpty } from './helpers/isNodeEmpty'\nimport { resolveFocusPosition } from './helpers/resolveFocusPosition'\nimport { style } from './style'\nimport {\n  CanCommands,\n  ChainedCommands,\n  EditorEvents,\n  EditorOptions,\n  JSONContent,\n  SingleCommands,\n  TextSerializer,\n} from './types'\nimport { createStyleTag } from './utilities/createStyleTag'\nimport { isFunction } from './utilities/isFunction'\n\nexport { extensions }\n\nexport interface HTMLElement {\n  editor?: Editor\n}\n\nexport class Editor extends EventEmitter<EditorEvents> {\n  private commandManager!: CommandManager\n\n  public extensionManager!: ExtensionManager\n\n  private css!: HTMLStyleElement\n\n  public schema!: Schema\n\n  public view!: EditorView\n\n  public isFocused = false\n\n  public extensionStorage: Record<string, any> = {}\n\n  public options: EditorOptions = {\n    element: document.createElement('div'),\n    content: '',\n    injectCSS: true,\n    injectNonce: undefined,\n    extensions: [],\n    autofocus: false,\n    editable: true,\n    editorProps: {},\n    parseOptions: {},\n    enableInputRules: true,\n    enablePasteRules: true,\n    enableCoreExtensions: true,\n    onBeforeCreate: () => null,\n    onCreate: () => null,\n    onUpdate: () => null,\n    onSelectionUpdate: () => null,\n    onTransaction: () => null,\n    onFocus: () => null,\n    onBlur: () => null,\n    onDestroy: () => null,\n  }\n\n  constructor(options: Partial<EditorOptions> = {}) {\n    super()\n    this.setOptions(options)\n    this.createExtensionManager()\n    this.createCommandManager()\n    this.createSchema()\n    this.on('beforeCreate', this.options.onBeforeCreate)\n    this.emit('beforeCreate', { editor: this })\n    this.createView()\n    this.injectCSS()\n    this.on('create', this.options.onCreate)\n    this.on('update', this.options.onUpdate)\n    this.on('selectionUpdate', this.options.onSelectionUpdate)\n    this.on('transaction', this.options.onTransaction)\n    this.on('focus', this.options.onFocus)\n    this.on('blur', this.options.onBlur)\n    this.on('destroy', this.options.onDestroy)\n\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return\n      }\n\n      this.commands.focus(this.options.autofocus)\n      this.emit('create', { editor: this })\n    }, 0)\n  }\n\n  /**\n   * Returns the editor storage.\n   */\n  public get storage(): Record<string, any> {\n    return this.extensionStorage\n  }\n\n  /**\n   * An object of all registered commands.\n   */\n  public get commands(): SingleCommands {\n    return this.commandManager.commands\n  }\n\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  public chain(): ChainedCommands {\n    return this.commandManager.chain()\n  }\n\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  public can(): CanCommands {\n    return this.commandManager.can()\n  }\n\n  /**\n   * Inject CSS styles.\n   */\n  private injectCSS(): void {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce)\n    }\n  }\n\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  public setOptions(options: Partial<EditorOptions> = {}): void {\n    this.options = {\n      ...this.options,\n      ...options,\n    }\n\n    if (!this.view || !this.state || this.isDestroyed) {\n      return\n    }\n\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps)\n    }\n\n    this.view.updateState(this.state)\n  }\n\n  /**\n   * Update editable state of the editor.\n   */\n  public setEditable(editable: boolean, emitUpdate = true): void {\n    this.setOptions({ editable })\n\n    if (emitUpdate) {\n      this.emit('update', { editor: this, transaction: this.state.tr })\n    }\n  }\n\n  /**\n   * Returns whether the editor is editable.\n   */\n  public get isEditable(): boolean {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable\n  }\n\n  /**\n   * Returns the editor state.\n   */\n  public get state(): EditorState {\n    return this.view.state\n  }\n\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   */\n  public registerPlugin(\n    plugin: Plugin,\n    handlePlugins?: (newPlugin: Plugin, plugins: Plugin[]) => Plugin[],\n  ): void {\n    const plugins = isFunction(handlePlugins)\n      ? handlePlugins(plugin, [...this.state.plugins])\n      : [...this.state.plugins, plugin]\n\n    const state = this.state.reconfigure({ plugins })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKey The plugins name\n   */\n  public unregisterPlugin(nameOrPluginKey: string | PluginKey): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    // @ts-ignore\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key\n\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\n    })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Creates an extension manager.\n   */\n  private createExtensionManager(): void {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : []\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension?.type)\n    })\n\n    this.extensionManager = new ExtensionManager(allExtensions, this)\n  }\n\n  /**\n   * Creates an command manager.\n   */\n  private createCommandManager(): void {\n    this.commandManager = new CommandManager({\n      editor: this,\n    })\n  }\n\n  /**\n   * Creates a ProseMirror schema.\n   */\n  private createSchema(): void {\n    this.schema = this.extensionManager.schema\n  }\n\n  /**\n   * Creates a ProseMirror view.\n   */\n  private createView(): void {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions)\n    const selection = resolveFocusPosition(doc, this.options.autofocus)\n\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined,\n      }),\n    })\n\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins,\n    })\n\n    this.view.updateState(newState)\n\n    this.createNodeViews()\n\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom as HTMLElement\n\n    dom.editor = this\n  }\n\n  /**\n   * Creates all node views.\n   */\n  public createNodeViews(): void {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews,\n    })\n  }\n\n  public isCapturingTransaction = false\n\n  private capturedTransaction: Transaction | null = null\n\n  public captureTransaction(fn: Function) {\n    this.isCapturingTransaction = true\n    fn()\n    this.isCapturingTransaction = false\n\n    const tr = this.capturedTransaction\n\n    this.capturedTransaction = null\n\n    return tr\n  }\n\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  private dispatchTransaction(transaction: Transaction): void {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return\n    }\n\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction\n\n        return\n      }\n\n      transaction.steps.forEach(step => this.capturedTransaction?.step(step))\n\n      return\n    }\n\n    const state = this.state.apply(transaction)\n    const selectionHasChanged = !this.state.selection.eq(state.selection)\n\n    this.view.updateState(state)\n    this.emit('transaction', {\n      editor: this,\n      transaction,\n    })\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction,\n      })\n    }\n\n    const focus = transaction.getMeta('focus')\n    const blur = transaction.getMeta('blur')\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction,\n      })\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction,\n      })\n    }\n\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction,\n    })\n  }\n\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  public getAttributes(nameOrType: string | NodeType | MarkType): Record<string, any> {\n    return getAttributes(this.state, nameOrType)\n  }\n\n  /**\n   * Returns if the currently selected node or mark is active.\n   *\n   * @param name Name of the node or mark\n   * @param attributes Attributes of the node or mark\n   */\n  public isActive(name: string, attributes?: {}): boolean\n  public isActive(attributes: {}): boolean\n  public isActive(nameOrAttributes: string, attributesOrUndefined?: {}): boolean {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null\n\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes\n\n    return isActive(this.state, name, attributes)\n  }\n\n  /**\n   * Get the document as JSON.\n   */\n  public getJSON(): JSONContent {\n    return this.state.doc.toJSON()\n  }\n\n  /**\n   * Get the document as HTML.\n   */\n  public getHTML(): string {\n    return getHTMLFromFragment(this.state.doc.content, this.schema)\n  }\n\n  /**\n   * Get the document as text.\n   */\n  public getText(options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  }): string {\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers,\n      },\n    })\n  }\n\n  /**\n   * Check if there is no content.\n   */\n  public get isEmpty(): boolean {\n    return isNodeEmpty(this.state.doc)\n  }\n\n  /**\n   * Get the number of characters for the current document.\n   *\n   * @deprecated\n   */\n  public getCharacterCount(): number {\n    console.warn(\n      '[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.',\n    )\n\n    return this.state.doc.content.size - 2\n  }\n\n  /**\n   * Destroy the editor.\n   */\n  public destroy(): void {\n    this.emit('destroy')\n\n    if (this.view) {\n      this.view.destroy()\n    }\n\n    this.removeAllListeners()\n  }\n\n  /**\n   * Check if the editor is already destroyed.\n   */\n  public get isDestroyed(): boolean {\n    // @ts-ignore\n    return !this.view?.docView\n  }\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween'\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n */\nexport function markInputRule(config: {\n  find: InputRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n      let markEnd = range.to\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n */\nexport function nodeInputRule(config: {\n  find: InputRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const { tr } = state\n      const start = range.from\n      let end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n        let matchStart = start + offset\n\n        if (matchStart > end) {\n          matchStart = end\n        } else {\n          end = matchStart + match[1].length\n        }\n\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1]\n\n        tr.insertText(lastChar, start + match[0].length - 1)\n\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, config.type.create(attributes))\n      } else if (match[0]) {\n        tr.replaceWith(start, end, config.type.create(attributes))\n      }\n    },\n  })\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n */\nexport function textblockTypeInputRule(config: {\n  find: InputRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from)\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null\n      }\n\n      state.tr\n        .delete(range.from, range.to)\n        .setBlockType(range.from, range.from, config.type, attributes)\n    },\n  })\n}\n","import { InputRule, InputRuleFinder } from '../InputRule'\n\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n */\nexport function textInputRule(config: {\n  find: InputRuleFinder,\n  replace: string,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Node as ProseMirrorNode, NodeType } from '@tiptap/pm/model'\nimport { canJoin, findWrapping } from '@tiptap/pm/transform'\n\nimport { Editor } from '../Editor'\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if there’s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n */\nexport function wrappingInputRule(config: {\n  find: InputRuleFinder,\n  type: NodeType,\n  keepMarks?: boolean,\n  keepAttributes?: boolean,\n  editor?: Editor\n  getAttributes?:\n  | Record<string, any>\n  | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n  | false\n  | null\n  ,\n  joinPredicate?: (match: ExtendedRegExpMatchArray, node: ProseMirrorNode) => boolean,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state, range, match, chain,\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const tr = state.tr.delete(range.from, range.to)\n      const $start = tr.doc.resolve(range.from)\n      const blockRange = $start.blockRange()\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes)\n\n      if (!wrapping) {\n        return null\n      }\n\n      tr.wrap(blockRange, wrapping)\n\n      if (config.keepMarks && config.editor) {\n        const { selection, storedMarks } = state\n        const { splittableMarks } = config.editor.extensionManager\n        const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n          tr.ensureMarks(filteredMarks)\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList'\n\n        chain().updateAttributes(nodeType, attributes).run()\n      }\n\n      const before = tr.doc.resolve(range.from - 1).nodeBefore\n\n      if (\n        before\n        && before.type === config.type\n        && canJoin(tr.doc, range.from - 1)\n        && (!config.joinPredicate || config.joinPredicate(match, before))\n      ) {\n        tr.join(range.from - 1)\n      }\n    },\n  })\n}\n","import {\n  DOMOutputSpec, Mark as ProseMirrorMark, MarkSpec, MarkType,\n} from '@tiptap/pm/model'\nimport { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { MarkConfig } from '.'\nimport { Editor } from './Editor'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { InputRule } from './InputRule'\nimport { Node } from './Node'\nimport { PasteRule } from './PasteRule'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { mergeDeep } from './utilities/mergeDeep'\n\ndeclare module '@tiptap/core' {\n  export interface MarkConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Mark,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n\n    /**\n     * Keep mark after split node\n     */\n    keepOnSplit?: boolean | (() => boolean)\n\n    /**\n     * Inclusive\n     */\n    inclusive?:\n      | MarkSpec['inclusive']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['inclusive']\n          editor?: Editor\n        }) => MarkSpec['inclusive'])\n\n    /**\n     * Excludes\n     */\n    excludes?:\n      | MarkSpec['excludes']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['excludes']\n          editor?: Editor\n        }) => MarkSpec['excludes'])\n\n    /**\n     * Marks this Mark as exitable\n     */\n    exitable?: boolean | (() => boolean)\n\n    /**\n     * Group\n     */\n    group?:\n      | MarkSpec['group']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['group']\n          editor?: Editor\n        }) => MarkSpec['group'])\n\n    /**\n     * Spanning\n     */\n    spanning?:\n      | MarkSpec['spanning']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['spanning']\n          editor?: Editor\n        }) => MarkSpec['spanning'])\n\n    /**\n     * Code\n     */\n    code?:\n      | boolean\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['code']\n          editor?: Editor\n        }) => boolean)\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['parseHTML']\n      editor?: Editor\n    }) => MarkSpec['parseDOM']\n\n    /**\n     * Render HTML\n     */\n    renderHTML?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['renderHTML']\n            editor?: Editor\n          },\n          props: {\n            mark: ProseMirrorMark\n            HTMLAttributes: Record<string, any>\n          },\n        ) => DOMOutputSpec)\n      | null\n\n    /**\n     * Attributes\n     */\n    addAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addAttributes']\n      editor?: Editor\n    }) => Attributes | {}\n  }\n}\n\nexport class Mark<Options = any, Storage = any> {\n  type = 'mark'\n\n  name = 'mark'\n\n  parent: Mark | null = null\n\n  child: Mark | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: MarkConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<MarkConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<MarkConfig<O, S>> = {}) {\n    return new Mark<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<MarkConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Mark<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  static handleExit({ editor, mark }: { editor: Editor; mark: Mark }) {\n    const { tr } = editor.state\n    const currentPos = editor.state.selection.$from\n    const isAtEnd = currentPos.pos === currentPos.end()\n\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks()\n      const isInMark = !!currentMarks.find(m => m?.type.name === mark.name)\n\n      if (!isInMark) {\n        return false\n      }\n\n      const removeMark = currentMarks.find(m => m?.type.name === mark.name)\n\n      if (removeMark) {\n        tr.removeStoredMark(removeMark)\n      }\n      tr.insertText(' ', currentPos.pos)\n\n      editor.view.dispatch(tr)\n\n      return true\n    }\n\n    return false\n  }\n}\n","import {\n  DOMOutputSpec, Node as ProseMirrorNode, NodeSpec, NodeType,\n} from '@tiptap/pm/model'\nimport { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { NodeConfig } from '.'\nimport { Editor } from './Editor'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { InputRule } from './InputRule'\nimport { PasteRule } from './PasteRule'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  NodeViewRenderer,\n  ParentConfig,\n  RawCommands,\n} from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { mergeDeep } from './utilities/mergeDeep'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['extendMarkSchema']\n            editor?: Editor\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n\n    /**\n     * Node View\n     */\n    addNodeView?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['addNodeView']\n        }) => NodeViewRenderer)\n      | null\n\n    /**\n     * TopNode\n     */\n    topNode?: boolean\n\n    /**\n     * Content\n     */\n    content?:\n      | NodeSpec['content']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['content']\n          editor?: Editor\n        }) => NodeSpec['content'])\n\n    /**\n     * Marks\n     */\n    marks?:\n      | NodeSpec['marks']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['marks']\n          editor?: Editor\n        }) => NodeSpec['marks'])\n\n    /**\n     * Group\n     */\n    group?:\n      | NodeSpec['group']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['group']\n          editor?: Editor\n        }) => NodeSpec['group'])\n\n    /**\n     * Inline\n     */\n    inline?:\n      | NodeSpec['inline']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['inline']\n          editor?: Editor\n        }) => NodeSpec['inline'])\n\n    /**\n     * Atom\n     */\n    atom?:\n      | NodeSpec['atom']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['atom']\n          editor?: Editor\n        }) => NodeSpec['atom'])\n\n    /**\n     * Selectable\n     */\n    selectable?:\n      | NodeSpec['selectable']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['selectable']\n          editor?: Editor\n        }) => NodeSpec['selectable'])\n\n    /**\n     * Draggable\n     */\n    draggable?:\n      | NodeSpec['draggable']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['draggable']\n          editor?: Editor\n        }) => NodeSpec['draggable'])\n\n    /**\n     * Code\n     */\n    code?:\n      | NodeSpec['code']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['code']\n          editor?: Editor\n        }) => NodeSpec['code'])\n\n    /**\n     * Whitespace\n     */\n    whitespace?:\n      | NodeSpec['whitespace']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['whitespace']\n          editor?: Editor\n        }) => NodeSpec['whitespace'])\n\n    /**\n     * Defining\n     */\n    defining?:\n      | NodeSpec['defining']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['defining']\n          editor?: Editor\n        }) => NodeSpec['defining'])\n\n    /**\n     * Isolating\n     */\n    isolating?:\n      | NodeSpec['isolating']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['isolating']\n          editor?: Editor\n        }) => NodeSpec['isolating'])\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['parseHTML']\n      editor?: Editor\n    }) => NodeSpec['parseDOM']\n\n    /**\n     * Render HTML\n     */\n    renderHTML?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['renderHTML']\n            editor?: Editor\n          },\n          props: {\n            node: ProseMirrorNode\n            HTMLAttributes: Record<string, any>\n          },\n        ) => DOMOutputSpec)\n      | null\n\n    /**\n     * Render Text\n     */\n    renderText?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['renderText']\n            editor?: Editor\n          },\n          props: {\n            node: ProseMirrorNode\n            pos: number\n            parent: ProseMirrorNode\n            index: number\n          },\n        ) => string)\n      | null\n\n    /**\n     * Add Attributes\n     */\n    addAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addAttributes']\n      editor?: Editor\n    }) => Attributes | {}\n  }\n}\n\nexport class Node<Options = any, Storage = any> {\n  type = 'node'\n\n  name = 'node'\n\n  parent: Node | null = null\n\n  child: Node | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: NodeConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<NodeConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<NodeConfig<O, S>> = {}) {\n    return new Node<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<NodeConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Node<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { NodeSelection } from '@tiptap/pm/state'\nimport { NodeView as ProseMirrorNodeView } from '@tiptap/pm/view'\n\nimport { Editor as CoreEditor } from './Editor'\nimport { Node } from './Node'\nimport { DecorationWithType, NodeViewRendererOptions, NodeViewRendererProps } from './types'\nimport { isiOS } from './utilities/isiOS'\n\nexport class NodeView<\n  Component,\n  NodeEditor extends CoreEditor = CoreEditor,\n  Options extends NodeViewRendererOptions = NodeViewRendererOptions,\n> implements ProseMirrorNodeView {\n  component: Component\n\n  editor: NodeEditor\n\n  options: Options\n\n  extension: Node\n\n  node: ProseMirrorNode\n\n  decorations: DecorationWithType[]\n\n  getPos: any\n\n  isDragging = false\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    this.component = component\n    this.editor = props.editor as NodeEditor\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options,\n    } as Options\n    this.extension = props.extension\n    this.node = props.node\n    this.decorations = props.decorations as DecorationWithType[]\n    this.getPos = props.getPos\n    this.mount()\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return\n  }\n\n  get dom(): HTMLElement {\n    return this.editor.view.dom as HTMLElement\n  }\n\n  get contentDOM(): HTMLElement | null {\n    return null\n  }\n\n  onDragStart(event: DragEvent) {\n    const { view } = this.editor\n    const target = event.target as HTMLElement\n\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3\n      ? target.parentElement?.closest('[data-drag-handle]')\n      : target.closest('[data-drag-handle]')\n\n    if (!this.dom || this.contentDOM?.contains(target) || !dragHandle) {\n      return\n    }\n\n    let x = 0\n    let y = 0\n\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect()\n      const handleBox = dragHandle.getBoundingClientRect()\n\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = event.offsetX ?? (event as any).nativeEvent?.offsetX\n      const offsetY = event.offsetY ?? (event as any).nativeEvent?.offsetY\n\n      x = handleBox.x - domBox.x + offsetX\n      y = handleBox.y - domBox.y + offsetY\n    }\n\n    event.dataTransfer?.setDragImage(this.dom, x, y)\n\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos())\n    const transaction = view.state.tr.setSelection(selection)\n\n    view.dispatch(transaction)\n  }\n\n  stopEvent(event: Event) {\n    if (!this.dom) {\n      return false\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({ event })\n    }\n\n    const target = event.target as HTMLElement\n    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target)\n\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false\n    }\n\n    const isDragEvent = event.type.startsWith('drag')\n    const isDropEvent = event.type === 'drop'\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable\n\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true\n    }\n\n    const { isEditable } = this.editor\n    const { isDragging } = this\n    const isDraggable = !!this.node.type.spec.draggable\n    const isSelectable = NodeSelection.isSelectable(this.node)\n    const isCopyEvent = event.type === 'copy'\n    const isPasteEvent = event.type === 'paste'\n    const isCutEvent = event.type === 'cut'\n    const isClickEvent = event.type === 'mousedown'\n\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault()\n    }\n\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault()\n      return false\n    }\n\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]')\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle))\n\n      if (isValidDragHandle) {\n        this.isDragging = true\n\n        document.addEventListener(\n          'dragend',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'drop',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'mouseup',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n      }\n    }\n\n    // these events are handled by prosemirror\n    if (\n      isDragging\n      || isDropEvent\n      || isCopyEvent\n      || isPasteEvent\n      || isCutEvent\n      || (isClickEvent && isSelectable)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  ignoreMutation(mutation: MutationRecord | { type: 'selection'; target: Element }) {\n    if (!this.dom || !this.contentDOM) {\n      return true\n    }\n\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({ mutation })\n    }\n\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true\n    }\n\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false\n    }\n\n    // try to prevent a bug on iOS that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    if (\n      this.dom.contains(mutation.target)\n      && mutation.type === 'childList'\n      && isiOS()\n      && this.editor.isFocused\n    ) {\n      const changedNodes = [\n        ...Array.from(mutation.addedNodes),\n        ...Array.from(mutation.removedNodes),\n      ] as HTMLElement[]\n\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false\n      }\n    }\n\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true\n    }\n\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false\n    }\n\n    return true\n  }\n\n  updateAttributes(attributes: {}) {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos()\n\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes,\n      })\n\n      return true\n    })\n  }\n\n  deleteNode(): void {\n    const from = this.getPos()\n    const to = from + this.node.nodeSize\n\n    this.editor.commands.deleteRange({ from, to })\n  }\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween'\nimport { PasteRule, PasteRuleFinder } from '../PasteRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n */\nexport function markPasteRule(config: {\n  find: PasteRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n      let markEnd = range.to\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","// source: https://stackoverflow.com/a/6969486\nexport function escapeForRegEx(string: string): string {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n","export function isString(value: any): value is string {\n  return typeof value === 'string'\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { PasteRule, PasteRuleFinder } from '../PasteRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities'\n\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n */\nexport function nodePasteRule(config: {\n  find: PasteRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler({ match, chain, range }) {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes,\n        })\n      }\n    },\n  })\n}\n","import { PasteRule, PasteRuleFinder } from '../PasteRule'\n\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n */\nexport function textPasteRule(config: {\n  find: PasteRuleFinder,\n  replace: string,\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Transaction } from '@tiptap/pm/state'\n\nexport interface TrackerResult {\n  position: number\n  deleted: boolean\n}\n\nexport class Tracker {\n  transaction: Transaction\n\n  currentStep: number\n\n  constructor(transaction: Transaction) {\n    this.transaction = transaction\n    this.currentStep = this.transaction.steps.length\n  }\n\n  map(position: number): TrackerResult {\n    let deleted = false\n\n    const mappedPosition = this.transaction.steps\n      .slice(this.currentStep)\n      .reduce((newPosition, step) => {\n        const mapResult = step.getMap().mapResult(newPosition)\n\n        if (mapResult.deleted) {\n          deleted = true\n        }\n\n        return mapResult.pos\n      }, position)\n\n    return {\n      position: mappedPosition,\n      deleted,\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}